var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"LineFollowing3","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LineFollowing3.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  LineFollowing3_step();\r\n\r\n  /* Get model outputs here */\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  noInterrupts();\r\n\r\n#endif;\r\n\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.01;\r\n  float systemClock = 0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n  init();\r\n  MW_usbattach();\r\n  MW_Arduino_Init();\r\n  rtmSetErrorStatus(LineFollowing3_M, 0);\r\n  LineFollowing3_initialize();\r\n  noInterrupts();\r\n  configureArduinoARM_M0plusTimer();\r\n  runModel = rtmGetErrorStatus(LineFollowing3_M) == (NULL);\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  interrupts();\r\n  while (runModel) {\r\n    stopRequested = !(rtmGetErrorStatus(LineFollowing3_M) == (NULL));\r\n    MW_Arduino_Loop();\r\n  }\r\n\r\n  /* Terminate model */\r\n  LineFollowing3_terminate();\r\n  MW_Arduino_Terminate();\r\n  noInterrupts();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LineFollowing3.c","type":"source","group":"model","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LineFollowing3.c\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LineFollowing3.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"LineFollowing3_private.h\"\r\n#include \"LineFollowing3_types.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n/* Named constants for Chart: '<Root>/Line Following' */\r\n#define LineFollowin_IN_MeasurementPoint ((uint8_T)3U)\r\n#define LineFollowing3_IN_CheckEnd     ((uint8_T)1U)\r\n#define LineFollowing3_IN_Drive        ((uint8_T)2U)\r\n#define LineFollowing3_IN_Pivot        ((uint8_T)4U)\r\n#define LineFollowing3_IN_PlusPoint    ((uint8_T)5U)\r\n#define LineFollowing3_IN_TPoint       ((uint8_T)6U)\r\n#define LineFollowing3_IN_TurnLeft     ((uint8_T)7U)\r\n#define LineFollowing3_IN_TurnRight    ((uint8_T)8U)\r\n#define LineFollowing3_IN_WaitASec     ((uint8_T)9U)\r\n\r\n/* Block signals (default storage) */\r\nB_LineFollowing3_T LineFollowing3_B;\r\n\r\n/* Block states (default storage) */\r\nDW_LineFollowing3_T LineFollowing3_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_LineFollowing3_T LineFollowing3_M_;\r\nRT_MODEL_LineFollowing3_T *const LineFollowing3_M = &LineFollowing3_M_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic real_T LineFollowing3_rand(void);\r\nstatic void rate_scheduler(void);\r\nuint32_T plook_u32d_binckan(real_T u, const real_T bp[], uint32_T maxIndex)\r\n{\r\n  uint32_T bpIndex;\r\n\r\n  /* Prelookup - Index only\r\n     Index Search method: 'binary'\r\n     Interpolation method: 'Use nearest'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u <= bp[0U]) {\r\n    bpIndex = 0U;\r\n  } else if (u < bp[maxIndex]) {\r\n    bpIndex = binsearch_u32d(u, bp, maxIndex >> 1U, maxIndex);\r\n    if ((bpIndex < maxIndex) && (bp[bpIndex + 1U] - u <= u - bp[bpIndex])) {\r\n      bpIndex++;\r\n    }\r\n  } else {\r\n    bpIndex = maxIndex;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\nuint32_T binsearch_u32d(real_T u, const real_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex)\r\n{\r\n  uint32_T bpIdx;\r\n  uint32_T bpIndex;\r\n  uint32_T iRght;\r\n\r\n  /* Binary Search */\r\n  bpIdx = startIndex;\r\n  bpIndex = 0U;\r\n  iRght = maxIndex;\r\n  while (iRght - bpIndex > 1U) {\r\n    if (u < bp[bpIdx]) {\r\n      iRght = bpIdx;\r\n    } else {\r\n      bpIndex = bpIdx;\r\n    }\r\n\r\n    bpIdx = (iRght + bpIndex) >> 1U;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate.\r\n *         The function is called at model base rate, hence the\r\n *         generated code self-manages all its subrates.\r\n */\r\nstatic void rate_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (LineFollowing3_M->Timing.TaskCounters.TID[1])++;\r\n  if ((LineFollowing3_M->Timing.TaskCounters.TID[1]) > 9) {/* Sample time: [0.1s, 0.0s] */\r\n    LineFollowing3_M->Timing.TaskCounters.TID[1] = 0;\r\n  }\r\n\r\n  (LineFollowing3_M->Timing.TaskCounters.TID[2])++;\r\n  if ((LineFollowing3_M->Timing.TaskCounters.TID[2]) > 99) {/* Sample time: [1.0s, 0.0s] */\r\n    LineFollowing3_M->Timing.TaskCounters.TID[2] = 0;\r\n  }\r\n}\r\n\r\nreal_T rt_roundd_snf(real_T u)\r\n{\r\n  real_T y;\r\n  if (fabs(u) < 4.503599627370496E+15) {\r\n    if (u >= 0.5) {\r\n      y = floor(u + 0.5);\r\n    } else if (u > -0.5) {\r\n      y = u * 0.0;\r\n    } else {\r\n      y = ceil(u - 0.5);\r\n    }\r\n  } else {\r\n    y = u;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic real_T LineFollowing3_rand(void)\r\n{\r\n  real_T r;\r\n  int32_T b_kk;\r\n  int32_T exitg1;\r\n  int32_T k;\r\n  uint32_T b_u[2];\r\n  uint32_T mti;\r\n  uint32_T y;\r\n  boolean_T b_isvalid;\r\n  boolean_T exitg2;\r\n  if (LineFollowing3_DW.method == 4U) {\r\n    k = (int32_T)(LineFollowing3_DW.state / 127773U);\r\n    mti = (LineFollowing3_DW.state - (uint32_T)k * 127773U) * 16807U;\r\n    y = 2836U * (uint32_T)k;\r\n    if (mti < y) {\r\n      LineFollowing3_DW.state = ~(y - mti) & 2147483647U;\r\n    } else {\r\n      LineFollowing3_DW.state = mti - y;\r\n    }\r\n\r\n    r = (real_T)LineFollowing3_DW.state * 4.6566128752457969E-10;\r\n  } else if (LineFollowing3_DW.method == 5U) {\r\n    mti = 69069U * LineFollowing3_DW.state_c[0] + 1234567U;\r\n    y = LineFollowing3_DW.state_c[1] << 13 ^ LineFollowing3_DW.state_c[1];\r\n    y ^= y >> 17;\r\n    y ^= y << 5;\r\n    LineFollowing3_DW.state_c[0] = mti;\r\n    LineFollowing3_DW.state_c[1] = y;\r\n    r = (real_T)(mti + y) * 2.328306436538696E-10;\r\n  } else {\r\n    /* ========================= COPYRIGHT NOTICE ============================ */\r\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\r\n    /*                                                                         */\r\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\r\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\r\n    /*                                                                         */\r\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\r\n    /*  All rights reserved.                                                   */\r\n    /*                                                                         */\r\n    /*  Redistribution and use in source and binary forms, with or without     */\r\n    /*  modification, are permitted provided that the following conditions     */\r\n    /*  are met:                                                               */\r\n    /*                                                                         */\r\n    /*    1. Redistributions of source code must retain the above copyright    */\r\n    /*       notice, this list of conditions and the following disclaimer.     */\r\n    /*                                                                         */\r\n    /*    2. Redistributions in binary form must reproduce the above copyright */\r\n    /*       notice, this list of conditions and the following disclaimer      */\r\n    /*       in the documentation and/or other materials provided with the     */\r\n    /*       distribution.                                                     */\r\n    /*                                                                         */\r\n    /*    3. The names of its contributors may not be used to endorse or       */\r\n    /*       promote products derived from this software without specific      */\r\n    /*       prior written permission.                                         */\r\n    /*                                                                         */\r\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\r\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\r\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\r\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\r\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\r\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\r\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\r\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\r\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\r\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\r\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\r\n    /*                                                                         */\r\n    /* =============================   END   ================================= */\r\n    do {\r\n      exitg1 = 0;\r\n      for (k = 0; k < 2; k++) {\r\n        mti = LineFollowing3_DW.state_m[624] + 1U;\r\n        if (LineFollowing3_DW.state_m[624] + 1U >= 625U) {\r\n          for (b_kk = 0; b_kk < 227; b_kk++) {\r\n            y = (LineFollowing3_DW.state_m[b_kk + 1] & 2147483647U) |\r\n              (LineFollowing3_DW.state_m[b_kk] & 2147483648U);\r\n            if ((y & 1U) == 0U) {\r\n              mti = y >> 1U;\r\n            } else {\r\n              mti = y >> 1U ^ 2567483615U;\r\n            }\r\n\r\n            LineFollowing3_DW.state_m[b_kk] = LineFollowing3_DW.state_m[b_kk +\r\n              397] ^ mti;\r\n          }\r\n\r\n          for (b_kk = 0; b_kk < 396; b_kk++) {\r\n            y = (LineFollowing3_DW.state_m[b_kk + 227] & 2147483648U) |\r\n              (LineFollowing3_DW.state_m[b_kk + 228] & 2147483647U);\r\n            if ((y & 1U) == 0U) {\r\n              mti = y >> 1U;\r\n            } else {\r\n              mti = y >> 1U ^ 2567483615U;\r\n            }\r\n\r\n            LineFollowing3_DW.state_m[b_kk + 227] =\r\n              LineFollowing3_DW.state_m[b_kk] ^ mti;\r\n          }\r\n\r\n          y = (LineFollowing3_DW.state_m[623] & 2147483648U) |\r\n            (LineFollowing3_DW.state_m[0] & 2147483647U);\r\n          if ((y & 1U) == 0U) {\r\n            mti = y >> 1U;\r\n          } else {\r\n            mti = y >> 1U ^ 2567483615U;\r\n          }\r\n\r\n          LineFollowing3_DW.state_m[623] = LineFollowing3_DW.state_m[396] ^ mti;\r\n          mti = 1U;\r\n        }\r\n\r\n        y = LineFollowing3_DW.state_m[(int32_T)mti - 1];\r\n        LineFollowing3_DW.state_m[624] = mti;\r\n        y ^= y >> 11U;\r\n        y ^= y << 7U & 2636928640U;\r\n        y ^= y << 15U & 4022730752U;\r\n        b_u[k] = y >> 18U ^ y;\r\n      }\r\n\r\n      r = ((real_T)(b_u[0] >> 5U) * 6.7108864E+7 + (real_T)(b_u[1] >> 6U)) *\r\n        1.1102230246251565E-16;\r\n      if (r == 0.0) {\r\n        if ((LineFollowing3_DW.state_m[624] >= 1U) &&\r\n            (LineFollowing3_DW.state_m[624] < 625U)) {\r\n          b_isvalid = true;\r\n        } else {\r\n          b_isvalid = false;\r\n        }\r\n\r\n        if (b_isvalid) {\r\n          b_isvalid = false;\r\n          k = 0;\r\n          exitg2 = false;\r\n          while ((!exitg2) && (k + 1 < 625)) {\r\n            if (LineFollowing3_DW.state_m[k] == 0U) {\r\n              k++;\r\n            } else {\r\n              b_isvalid = true;\r\n              exitg2 = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (!b_isvalid) {\r\n          mti = 5489U;\r\n          LineFollowing3_DW.state_m[0] = 5489U;\r\n          for (k = 0; k < 623; k++) {\r\n            mti = ((mti >> 30U ^ mti) * 1812433253U + (uint32_T)k) + 1U;\r\n            LineFollowing3_DW.state_m[k + 1] = mti;\r\n          }\r\n\r\n          LineFollowing3_DW.state_m[624] = 624U;\r\n        }\r\n      } else {\r\n        exitg1 = 1;\r\n      }\r\n    } while (exitg1 == 0);\r\n  }\r\n\r\n  return r;\r\n}\r\n\r\n/* Model step function */\r\nvoid LineFollowing3_step(void)\r\n{\r\n  codertarget_arduinobase_intern_T *obj;\r\n  real_T rtb_LeftPWM_f;\r\n  real_T rtb_Switch1;\r\n  real_T tmp;\r\n  uint32_T duration;\r\n  uint8_T tmp_0;\r\n  boolean_T tmp_1;\r\n  boolean_T tmp_2;\r\n  if (LineFollowing3_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* MATLABSystem: '<Root>/sense3' */\r\n    if (LineFollowing3_DW.obj_h.SampleTime != LineFollowing3_P.sense3_SampleTime)\r\n    {\r\n      LineFollowing3_DW.obj_h.SampleTime = LineFollowing3_P.sense3_SampleTime;\r\n    }\r\n\r\n    /* MATLABSystem: '<Root>/sense3' */\r\n    LineFollowing3_B.sense3 = readDigitalPin(9);\r\n\r\n    /* MATLABSystem: '<Root>/sense2' */\r\n    if (LineFollowing3_DW.obj_b.SampleTime != LineFollowing3_P.sense2_SampleTime)\r\n    {\r\n      LineFollowing3_DW.obj_b.SampleTime = LineFollowing3_P.sense2_SampleTime;\r\n    }\r\n\r\n    /* MATLABSystem: '<Root>/sense2' */\r\n    LineFollowing3_B.sense2 = readDigitalPin(10);\r\n\r\n    /* MATLABSystem: '<Root>/sense4' */\r\n    if (LineFollowing3_DW.obj.SampleTime != LineFollowing3_P.sense4_SampleTime)\r\n    {\r\n      LineFollowing3_DW.obj.SampleTime = LineFollowing3_P.sense4_SampleTime;\r\n    }\r\n\r\n    /* MATLABSystem: '<Root>/sense4' */\r\n    LineFollowing3_B.sense4 = readDigitalPin(8);\r\n\r\n    /* MATLABSystem: '<Root>/sense1' */\r\n    if (LineFollowing3_DW.obj_m.SampleTime != LineFollowing3_P.sense1_SampleTime)\r\n    {\r\n      LineFollowing3_DW.obj_m.SampleTime = LineFollowing3_P.sense1_SampleTime;\r\n    }\r\n\r\n    /* MATLABSystem: '<Root>/sense1' */\r\n    LineFollowing3_B.sense1 = readDigitalPin(11);\r\n  }\r\n\r\n  /* MATLABSystem: '<Root>/Ultrasonic Sensor' */\r\n  if (LineFollowing3_DW.obj_bs.TunablePropsChanged) {\r\n    LineFollowing3_DW.obj_bs.TunablePropsChanged = false;\r\n  }\r\n\r\n  MW_UltrasonicRead(&duration, 1, 13, 12, 10);\r\n\r\n  /* Chart: '<Root>/Line Following' incorporates:\r\n   *  MATLABSystem: '<Root>/Ultrasonic Sensor'\r\n   */\r\n  if (LineFollowing3_DW.temporalCounter_i1 < 127U) {\r\n    LineFollowing3_DW.temporalCounter_i1++;\r\n  }\r\n\r\n  if (LineFollowing3_DW.is_active_c1_LineFollowing3 == 0U) {\r\n    LineFollowing3_DW.is_active_c1_LineFollowing3 = 1U;\r\n    LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Drive;\r\n    LineFollowing3_B.v = 2.5;\r\n    LineFollowing3_B.w = 0.0;\r\n  } else {\r\n    switch (LineFollowing3_DW.is_c1_LineFollowing3) {\r\n     case LineFollowing3_IN_CheckEnd:\r\n      LineFollowing3_B.v = 2.0;\r\n      tmp_1 = ((!LineFollowing3_B.sense1) && LineFollowing3_B.sense2 &&\r\n               LineFollowing3_B.sense3 && (!LineFollowing3_B.sense4));\r\n      if (tmp_1 && ((real_T)duration * 0.000343 / 2.0 != 0.0)) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 =\r\n          LineFollowin_IN_MeasurementPoint;\r\n        LineFollowing3_B.v = 0.0;\r\n      } else if (tmp_1) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_TPoint;\r\n        LineFollowing3_B.v = 0.0;\r\n      } else if (LineFollowing3_B.sense1 && (!LineFollowing3_B.sense2) &&\r\n                 (!LineFollowing3_B.sense3) && LineFollowing3_B.sense4) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_PlusPoint;\r\n        LineFollowing3_B.v = -1.0;\r\n      }\r\n      break;\r\n\r\n     case LineFollowing3_IN_Drive:\r\n      LineFollowing3_B.v = 2.5;\r\n      LineFollowing3_B.w = 0.0;\r\n      if (LineFollowing3_B.sense2 || LineFollowing3_B.sense3) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_WaitASec;\r\n        LineFollowing3_B.v = 0.0;\r\n      }\r\n      break;\r\n\r\n     case LineFollowin_IN_MeasurementPoint:\r\n      LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Pivot;\r\n      LineFollowing3_DW.temporalCounter_i1 = 0U;\r\n      LineFollowing3_B.v = 5.0;\r\n      LineFollowing3_B.w = -8.0;\r\n      break;\r\n\r\n     case LineFollowing3_IN_Pivot:\r\n      LineFollowing3_B.v = 5.0;\r\n      LineFollowing3_B.w = -8.0;\r\n      if (LineFollowing3_DW.temporalCounter_i1 >= 100U) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Drive;\r\n        LineFollowing3_B.v = 2.5;\r\n        LineFollowing3_B.w = 0.0;\r\n      }\r\n      break;\r\n\r\n     case LineFollowing3_IN_PlusPoint:\r\n      LineFollowing3_B.v = -1.0;\r\n      if ((!LineFollowing3_B.sense1) || (!LineFollowing3_B.sense4)) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_TPoint;\r\n        LineFollowing3_B.v = 0.0;\r\n      }\r\n      break;\r\n\r\n     case LineFollowing3_IN_TPoint:\r\n      LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Pivot;\r\n      LineFollowing3_DW.temporalCounter_i1 = 0U;\r\n      LineFollowing3_B.v = 5.0;\r\n      LineFollowing3_B.w = -8.0;\r\n      break;\r\n\r\n     case LineFollowing3_IN_TurnLeft:\r\n      LineFollowing3_B.v = 0.0;\r\n      LineFollowing3_B.w = 5.0;\r\n      if ((LineFollowing3_DW.temporalCounter_i1 >= 11U) &&\r\n          (!LineFollowing3_B.sense3)) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Drive;\r\n        LineFollowing3_B.v = 2.5;\r\n        LineFollowing3_B.w = 0.0;\r\n      }\r\n      break;\r\n\r\n     case LineFollowing3_IN_TurnRight:\r\n      LineFollowing3_B.v = 0.0;\r\n      LineFollowing3_B.w = -5.0;\r\n      if ((LineFollowing3_DW.temporalCounter_i1 >= 10U) &&\r\n          (!LineFollowing3_B.sense2)) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_Drive;\r\n        LineFollowing3_B.v = 2.5;\r\n        LineFollowing3_B.w = 0.0;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_WaitASec: */\r\n      LineFollowing3_B.v = 0.0;\r\n      LineFollowing3_B.w = 0.0;\r\n      tmp_1 = !LineFollowing3_B.sense2;\r\n      tmp_2 = !LineFollowing3_B.sense3;\r\n      if ((!LineFollowing3_B.sense1) && tmp_1 && tmp_2 &&\r\n          (!LineFollowing3_B.sense4)) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_CheckEnd;\r\n        LineFollowing3_B.v = 2.0;\r\n      } else if (LineFollowing3_B.sense1 && tmp_1 && LineFollowing3_B.sense4) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_TurnLeft;\r\n        LineFollowing3_DW.temporalCounter_i1 = 0U;\r\n        LineFollowing3_B.w = 5.0;\r\n      } else if (LineFollowing3_B.sense1 && tmp_2 && LineFollowing3_B.sense4) {\r\n        LineFollowing3_DW.is_c1_LineFollowing3 = LineFollowing3_IN_TurnRight;\r\n        LineFollowing3_DW.temporalCounter_i1 = 0U;\r\n        LineFollowing3_B.w = -5.0;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<Root>/Line Following' */\r\n\r\n  /* Gain: '<Root>/Gain' incorporates:\r\n   *  Sum: '<Root>/wR'\r\n   */\r\n  rtb_LeftPWM_f = (LineFollowing3_B.v + LineFollowing3_B.w) *\r\n    LineFollowing3_P.Gain_Gain;\r\n\r\n  /* Switch: '<Root>/Switch1' incorporates:\r\n   *  Constant: '<Root>/Constant4'\r\n   *  Constant: '<Root>/Constant5'\r\n   */\r\n  if (rtb_LeftPWM_f > LineFollowing3_P.Switch1_Threshold) {\r\n    rtb_Switch1 = LineFollowing3_P.Constant4_Value;\r\n  } else {\r\n    rtb_Switch1 = LineFollowing3_P.Constant5_Value;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch1' */\r\n\r\n  /* MATLABSystem: '<Root>/Right motor back' */\r\n  tmp = rt_roundd_snf(rtb_Switch1);\r\n  if (tmp < 256.0) {\r\n    if (tmp >= 0.0) {\r\n      tmp_0 = (uint8_T)tmp;\r\n    } else {\r\n      tmp_0 = 0U;\r\n    }\r\n  } else {\r\n    tmp_0 = MAX_uint8_T;\r\n  }\r\n\r\n  writeDigitalPin(7, tmp_0);\r\n\r\n  /* End of MATLABSystem: '<Root>/Right motor back' */\r\n\r\n  /* MATLABSystem: '<Root>/Right motor forward' incorporates:\r\n   *  Logic: '<Root>/NOT1'\r\n   */\r\n  writeDigitalPin(6, (uint8_T)!(rtb_Switch1 != 0.0));\r\n\r\n  /* MATLABSystem: '<Root>/Right PWM' */\r\n  obj = &LineFollowing3_DW.obj_p;\r\n  obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(17U);\r\n\r\n  /* Lookup_n-D: '<Root>/Left Motor LUT1' incorporates:\r\n   *  Sum: '<Root>/wL'\r\n   */\r\n  rtb_LeftPWM_f = LineFollowing3_P.InputPWM[plook_u32d_binckan(rtb_LeftPWM_f,\r\n    LineFollowing3_P.WheelSpeed, 172U)];\r\n\r\n  /* MATLABSystem: '<Root>/Right PWM' */\r\n  if (!(rtb_LeftPWM_f <= 255.0)) {\r\n    rtb_LeftPWM_f = 255.0;\r\n  }\r\n\r\n  if (!(rtb_LeftPWM_f >= 0.0)) {\r\n    rtb_LeftPWM_f = 0.0;\r\n  }\r\n\r\n  MW_PWM_SetDutyCycle(LineFollowing3_DW.obj_p.PWMDriverObj.MW_PWM_HANDLE,\r\n                      rtb_LeftPWM_f);\r\n\r\n  /* Sum: '<Root>/wL' */\r\n  rtb_LeftPWM_f = LineFollowing3_B.v - LineFollowing3_B.w;\r\n\r\n  /* Switch: '<Root>/Switch' incorporates:\r\n   *  Constant: '<Root>/Constant2'\r\n   *  Constant: '<Root>/Constant3'\r\n   */\r\n  if (rtb_LeftPWM_f > LineFollowing3_P.Switch_Threshold) {\r\n    LineFollowing3_B.v = LineFollowing3_P.Constant2_Value;\r\n  } else {\r\n    LineFollowing3_B.v = LineFollowing3_P.Constant3_Value;\r\n  }\r\n\r\n  /* End of Switch: '<Root>/Switch' */\r\n\r\n  /* MATLABSystem: '<Root>/Left motor back' */\r\n  tmp = rt_roundd_snf(LineFollowing3_B.v);\r\n  if (tmp < 256.0) {\r\n    if (tmp >= 0.0) {\r\n      tmp_0 = (uint8_T)tmp;\r\n    } else {\r\n      tmp_0 = 0U;\r\n    }\r\n  } else {\r\n    tmp_0 = MAX_uint8_T;\r\n  }\r\n\r\n  writeDigitalPin(5, tmp_0);\r\n\r\n  /* End of MATLABSystem: '<Root>/Left motor back' */\r\n\r\n  /* MATLABSystem: '<Root>/Left motor forward' incorporates:\r\n   *  Logic: '<Root>/NOT'\r\n   */\r\n  writeDigitalPin(4, (uint8_T)!(LineFollowing3_B.v != 0.0));\r\n\r\n  /* MATLABSystem: '<Root>/Left PWM' */\r\n  obj = &LineFollowing3_DW.obj_f;\r\n  obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(16U);\r\n\r\n  /* Lookup_n-D: '<Root>/Left Motor LUT' incorporates:\r\n   *  Sum: '<Root>/wL'\r\n   */\r\n  rtb_LeftPWM_f = LineFollowing3_P.InputPWM[plook_u32d_binckan(rtb_LeftPWM_f,\r\n    LineFollowing3_P.WheelSpeed, 172U)];\r\n\r\n  /* MATLABSystem: '<Root>/Left PWM' */\r\n  if (!(rtb_LeftPWM_f <= 255.0)) {\r\n    rtb_LeftPWM_f = 255.0;\r\n  }\r\n\r\n  if (!(rtb_LeftPWM_f >= 0.0)) {\r\n    rtb_LeftPWM_f = 0.0;\r\n  }\r\n\r\n  MW_PWM_SetDutyCycle(LineFollowing3_DW.obj_f.PWMDriverObj.MW_PWM_HANDLE,\r\n                      rtb_LeftPWM_f);\r\n  if (LineFollowing3_M->Timing.TaskCounters.TID[2] == 0) {\r\n    /* MATLABSystem: '<Root>/Random Integer Generator' */\r\n    LineFollowing3_rand();\r\n  }\r\n\r\n  rate_scheduler();\r\n}\r\n\r\n/* Model initialize function */\r\nvoid LineFollowing3_initialize(void)\r\n{\r\n  {\r\n    codertarget_arduinobase_intern_T *obj;\r\n    static const uint32_T tmp[625] = { 5489U, 1301868182U, 2938499221U,\r\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\r\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\r\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\r\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\r\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\r\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\r\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\r\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\r\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\r\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\r\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\r\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\r\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\r\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\r\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\r\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\r\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\r\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\r\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\r\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\r\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\r\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\r\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\r\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\r\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\r\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\r\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\r\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\r\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\r\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\r\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\r\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\r\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\r\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\r\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\r\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\r\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\r\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\r\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\r\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\r\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\r\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\r\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\r\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\r\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\r\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\r\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\r\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\r\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\r\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\r\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\r\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\r\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\r\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\r\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\r\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\r\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\r\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\r\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\r\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\r\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\r\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\r\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\r\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\r\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\r\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\r\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\r\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\r\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\r\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\r\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\r\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\r\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\r\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\r\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\r\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\r\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\r\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\r\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\r\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\r\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\r\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\r\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\r\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\r\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\r\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\r\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\r\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\r\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\r\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\r\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\r\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\r\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\r\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\r\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\r\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\r\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\r\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\r\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\r\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\r\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\r\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\r\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\r\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\r\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\r\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\r\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\r\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\r\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\r\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\r\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\r\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\r\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\r\n\r\n    /* Start for MATLABSystem: '<Root>/sense3' */\r\n    LineFollowing3_DW.obj_h.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_h.SampleTime = LineFollowing3_P.sense3_SampleTime;\r\n    LineFollowing3_DW.obj_h.isInitialized = 1;\r\n    digitalIOSetup(9, 0);\r\n    LineFollowing3_DW.obj_h.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/sense2' */\r\n    LineFollowing3_DW.obj_b.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_b.SampleTime = LineFollowing3_P.sense2_SampleTime;\r\n    LineFollowing3_DW.obj_b.isInitialized = 1;\r\n    digitalIOSetup(10, 0);\r\n    LineFollowing3_DW.obj_b.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/sense4' */\r\n    LineFollowing3_DW.obj.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj.SampleTime = LineFollowing3_P.sense4_SampleTime;\r\n    LineFollowing3_DW.obj.isInitialized = 1;\r\n    digitalIOSetup(8, 0);\r\n    LineFollowing3_DW.obj.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/sense1' */\r\n    LineFollowing3_DW.obj_m.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_m.SampleTime = LineFollowing3_P.sense1_SampleTime;\r\n    LineFollowing3_DW.obj_m.isInitialized = 1;\r\n    digitalIOSetup(11, 0);\r\n    LineFollowing3_DW.obj_m.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Ultrasonic Sensor' */\r\n    LineFollowing3_DW.obj_bs.isInitialized = 1;\r\n    MW_UltrasonicSetup(13, 12);\r\n    LineFollowing3_DW.obj_bs.TunablePropsChanged = false;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Right motor back' */\r\n    LineFollowing3_DW.obj_d.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_d.isInitialized = 1;\r\n    digitalIOSetup(7, 1);\r\n    LineFollowing3_DW.obj_d.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Right motor forward' */\r\n    LineFollowing3_DW.obj_hn.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_hn.isInitialized = 1;\r\n    digitalIOSetup(6, 1);\r\n    LineFollowing3_DW.obj_hn.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Right PWM' */\r\n    LineFollowing3_DW.obj_p.matlabCodegenIsDeleted = false;\r\n    obj = &LineFollowing3_DW.obj_p;\r\n    LineFollowing3_DW.obj_p.isInitialized = 1;\r\n    obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_Open(17U, 0.0, 0.0);\r\n    LineFollowing3_DW.obj_p.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Left motor back' */\r\n    LineFollowing3_DW.obj_m4.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_m4.isInitialized = 1;\r\n    digitalIOSetup(5, 1);\r\n    LineFollowing3_DW.obj_m4.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Left motor forward' */\r\n    LineFollowing3_DW.obj_k.matlabCodegenIsDeleted = false;\r\n    LineFollowing3_DW.obj_k.isInitialized = 1;\r\n    digitalIOSetup(4, 1);\r\n    LineFollowing3_DW.obj_k.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Left PWM' */\r\n    LineFollowing3_DW.obj_f.matlabCodegenIsDeleted = false;\r\n    obj = &LineFollowing3_DW.obj_f;\r\n    LineFollowing3_DW.obj_f.isInitialized = 1;\r\n    obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_Open(16U, 0.0, 0.0);\r\n    LineFollowing3_DW.obj_f.isSetupComplete = true;\r\n\r\n    /* Start for MATLABSystem: '<Root>/Random Integer Generator' */\r\n    LineFollowing3_DW.method = 7U;\r\n    LineFollowing3_DW.state = 1144108930U;\r\n    LineFollowing3_DW.state_c[0] = 362436069U;\r\n    LineFollowing3_DW.state_c[1] = 521288629U;\r\n    memcpy(&LineFollowing3_DW.state_m[0], &tmp[0], 625U * sizeof(uint32_T));\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid LineFollowing3_terminate(void)\r\n{\r\n  codertarget_arduinobase_intern_T *obj;\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/sense3' */\r\n  if (!LineFollowing3_DW.obj_h.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_h.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/sense3' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/sense2' */\r\n  if (!LineFollowing3_DW.obj_b.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_b.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/sense2' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/sense4' */\r\n  if (!LineFollowing3_DW.obj.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/sense4' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/sense1' */\r\n  if (!LineFollowing3_DW.obj_m.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_m.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/sense1' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Right motor back' */\r\n  if (!LineFollowing3_DW.obj_d.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_d.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Right motor back' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Right motor forward' */\r\n  if (!LineFollowing3_DW.obj_hn.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_hn.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Right motor forward' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Right PWM' */\r\n  obj = &LineFollowing3_DW.obj_p;\r\n  if (!LineFollowing3_DW.obj_p.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_p.matlabCodegenIsDeleted = true;\r\n    if ((LineFollowing3_DW.obj_p.isInitialized == 1) &&\r\n        LineFollowing3_DW.obj_p.isSetupComplete) {\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(17U);\r\n      MW_PWM_SetDutyCycle(LineFollowing3_DW.obj_p.PWMDriverObj.MW_PWM_HANDLE,\r\n                          0.0);\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(17U);\r\n      MW_PWM_Close(LineFollowing3_DW.obj_p.PWMDriverObj.MW_PWM_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Right PWM' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Left motor back' */\r\n  if (!LineFollowing3_DW.obj_m4.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_m4.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Left motor back' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Left motor forward' */\r\n  if (!LineFollowing3_DW.obj_k.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_k.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Left motor forward' */\r\n\r\n  /* Terminate for MATLABSystem: '<Root>/Left PWM' */\r\n  obj = &LineFollowing3_DW.obj_f;\r\n  if (!LineFollowing3_DW.obj_f.matlabCodegenIsDeleted) {\r\n    LineFollowing3_DW.obj_f.matlabCodegenIsDeleted = true;\r\n    if ((LineFollowing3_DW.obj_f.isInitialized == 1) &&\r\n        LineFollowing3_DW.obj_f.isSetupComplete) {\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(16U);\r\n      MW_PWM_SetDutyCycle(LineFollowing3_DW.obj_f.PWMDriverObj.MW_PWM_HANDLE,\r\n                          0.0);\r\n      obj->PWMDriverObj.MW_PWM_HANDLE = MW_PWM_GetHandle(16U);\r\n      MW_PWM_Close(LineFollowing3_DW.obj_f.PWMDriverObj.MW_PWM_HANDLE);\r\n    }\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/Left PWM' */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LineFollowing3.h","type":"header","group":"model","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LineFollowing3.h\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LineFollowing3_h_\r\n#define RTW_HEADER_LineFollowing3_h_\r\n#ifndef LineFollowing3_COMMON_INCLUDES_\r\n#define LineFollowing3_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"MW_PWM.h\"\r\n#include \"MW_arduino_digitalio.h\"\r\n#include \"MW_Ultrasonic.h\"\r\n#endif                                 /* LineFollowing3_COMMON_INCLUDES_ */\r\n\r\n#include \"LineFollowing3_types.h\"\r\n#include <stddef.h>\r\n#include \"MW_target_hardware_resources.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T w;                            /* '<Root>/Line Following' */\r\n  real_T v;                            /* '<Root>/Line Following' */\r\n  boolean_T sense4;                    /* '<Root>/sense4' */\r\n  boolean_T sense3;                    /* '<Root>/sense3' */\r\n  boolean_T sense2;                    /* '<Root>/sense2' */\r\n  boolean_T sense1;                    /* '<Root>/sense1' */\r\n} B_LineFollowing3_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  codertarget_arduinobase_bloc_j_T obj;/* '<Root>/sense4' */\r\n  codertarget_arduinobase_bloc_j_T obj_h;/* '<Root>/sense3' */\r\n  codertarget_arduinobase_bloc_j_T obj_b;/* '<Root>/sense2' */\r\n  codertarget_arduinobase_bloc_j_T obj_m;/* '<Root>/sense1' */\r\n  codertarget_arduinobase_blocks_T obj_hn;/* '<Root>/Right motor forward' */\r\n  codertarget_arduinobase_blocks_T obj_d;/* '<Root>/Right motor back' */\r\n  codertarget_arduinobase_blocks_T obj_k;/* '<Root>/Left motor forward' */\r\n  codertarget_arduinobase_blocks_T obj_m4;/* '<Root>/Left motor back' */\r\n  codertarget_arduinobase_intern_T obj_p;/* '<Root>/Right PWM' */\r\n  codertarget_arduinobase_intern_T obj_f;/* '<Root>/Left PWM' */\r\n  codertarget_arduinobase_inte_j_T obj_bs;/* '<Root>/Ultrasonic Sensor' */\r\n  uint32_T state;                      /* '<Root>/Random Integer Generator' */\r\n  uint32_T state_c[2];                 /* '<Root>/Random Integer Generator' */\r\n  uint32_T state_m[625];               /* '<Root>/Random Integer Generator' */\r\n  uint32_T method;                     /* '<Root>/Random Integer Generator' */\r\n  uint8_T is_active_c1_LineFollowing3; /* '<Root>/Line Following' */\r\n  uint8_T is_c1_LineFollowing3;        /* '<Root>/Line Following' */\r\n  uint8_T temporalCounter_i1;          /* '<Root>/Line Following' */\r\n} DW_LineFollowing3_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_LineFollowing3_T_ {\r\n  real_T InputPWM[173];                /* Variable: InputPWM\r\n                                        * Referenced by:\r\n                                        *   '<Root>/Left Motor LUT'\r\n                                        *   '<Root>/Left Motor LUT1'\r\n                                        */\r\n  real_T WheelSpeed[173];              /* Variable: WheelSpeed\r\n                                        * Referenced by:\r\n                                        *   '<Root>/Left Motor LUT'\r\n                                        *   '<Root>/Left Motor LUT1'\r\n                                        */\r\n  real_T Constant4_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant4'\r\n                                        */\r\n  real_T Constant5_Value;              /* Expression: 0\r\n                                        * Referenced by: '<Root>/Constant5'\r\n                                        */\r\n  real_T Constant2_Value;              /* Expression: 1\r\n                                        * Referenced by: '<Root>/Constant2'\r\n                                        */\r\n  real_T Constant3_Value;              /* Expression: 0\r\n                                        * Referenced by: '<Root>/Constant3'\r\n                                        */\r\n  real_T sense1_SampleTime;            /* Expression: 0.1\r\n                                        * Referenced by: '<Root>/sense1'\r\n                                        */\r\n  real_T sense2_SampleTime;            /* Expression: 0.1\r\n                                        * Referenced by: '<Root>/sense2'\r\n                                        */\r\n  real_T sense3_SampleTime;            /* Expression: 0.1\r\n                                        * Referenced by: '<Root>/sense3'\r\n                                        */\r\n  real_T sense4_SampleTime;            /* Expression: 0.1\r\n                                        * Referenced by: '<Root>/sense4'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 1.1\r\n                                        * Referenced by: '<Root>/Gain'\r\n                                        */\r\n  real_T Switch1_Threshold;            /* Expression: 0\r\n                                        * Referenced by: '<Root>/Switch1'\r\n                                        */\r\n  real_T Switch_Threshold;             /* Expression: 0\r\n                                        * Referenced by: '<Root>/Switch'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_LineFollowing3_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    struct {\r\n      uint8_T TID[3];\r\n    } TaskCounters;\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_LineFollowing3_T LineFollowing3_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_LineFollowing3_T LineFollowing3_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_LineFollowing3_T LineFollowing3_DW;\r\n\r\n/* Model entry point functions */\r\nextern void LineFollowing3_initialize(void);\r\nextern void LineFollowing3_step(void);\r\nextern void LineFollowing3_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_LineFollowing3_T *const LineFollowing3_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Display' : Unused code path elimination\r\n * Block '<Root>/Display1' : Unused code path elimination\r\n * Block '<Root>/Display2' : Unused code path elimination\r\n * Block '<Root>/Display3' : Unused code path elimination\r\n * Block '<Root>/Distance' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'LineFollowing3'\r\n * '<S1>'   : 'LineFollowing3/Line Following'\r\n */\r\n#endif                                 /* RTW_HEADER_LineFollowing3_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LineFollowing3_private.h","type":"header","group":"model","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LineFollowing3_private.h\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LineFollowing3_private_h_\r\n#define RTW_HEADER_LineFollowing3_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"LineFollowing3_types.h\"\r\n#include \"LineFollowing3.h\"\r\n\r\nextern real_T rt_roundd_snf(real_T u);\r\nextern uint32_T plook_u32d_binckan(real_T u, const real_T bp[], uint32_T\r\n  maxIndex);\r\nextern uint32_T binsearch_u32d(real_T u, const real_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex);\r\n\r\n#endif                                /* RTW_HEADER_LineFollowing3_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LineFollowing3_types.h","type":"header","group":"model","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LineFollowing3_types.h\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_LineFollowing3_types_h_\r\n#define RTW_HEADER_LineFollowing3_types_h_\r\n#include \"MW_SVD.h\"\r\n#include \"rtwtypes.h\"\r\n\r\n/* Custom Type definition for MATLABSystem: '<Root>/Right PWM' */\r\n#include \"MW_SVD.h\"\r\n#ifndef struct_tag_g1WX34VPn8QzVKQriB4HN\r\n#define struct_tag_g1WX34VPn8QzVKQriB4HN\r\n\r\nstruct tag_g1WX34VPn8QzVKQriB4HN\r\n{\r\n  MW_Handle_Type MW_PWM_HANDLE;\r\n};\r\n\r\n#endif                                 /* struct_tag_g1WX34VPn8QzVKQriB4HN */\r\n\r\n#ifndef typedef_g_matlabshared_ioclient_periph_T\r\n#define typedef_g_matlabshared_ioclient_periph_T\r\n\r\ntypedef struct tag_g1WX34VPn8QzVKQriB4HN g_matlabshared_ioclient_periph_T;\r\n\r\n#endif                            /* typedef_g_matlabshared_ioclient_periph_T */\r\n\r\n#ifndef struct_tag_4eDVzK5FiryyCjvjjvrZGB\r\n#define struct_tag_4eDVzK5FiryyCjvjjvrZGB\r\n\r\nstruct tag_4eDVzK5FiryyCjvjjvrZGB\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  g_matlabshared_ioclient_periph_T PWMDriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_4eDVzK5FiryyCjvjjvrZGB */\r\n\r\n#ifndef typedef_codertarget_arduinobase_intern_T\r\n#define typedef_codertarget_arduinobase_intern_T\r\n\r\ntypedef struct tag_4eDVzK5FiryyCjvjjvrZGB codertarget_arduinobase_intern_T;\r\n\r\n#endif                            /* typedef_codertarget_arduinobase_intern_T */\r\n\r\n#ifndef struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n#define struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n\r\nstruct tag_9aqKbsbsI7JI0RwgnVwU0C\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_9aqKbsbsI7JI0RwgnVwU0C */\r\n\r\n#ifndef typedef_b_arduinodriver_ArduinoDigital_T\r\n#define typedef_b_arduinodriver_ArduinoDigital_T\r\n\r\ntypedef struct tag_9aqKbsbsI7JI0RwgnVwU0C b_arduinodriver_ArduinoDigital_T;\r\n\r\n#endif                            /* typedef_b_arduinodriver_ArduinoDigital_T */\r\n\r\n#ifndef struct_tag_qrLkTWTW64zZK0sqwALTyG\r\n#define struct_tag_qrLkTWTW64zZK0sqwALTyG\r\n\r\nstruct tag_qrLkTWTW64zZK0sqwALTyG\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_arduinodriver_ArduinoDigital_T DigitalIODriverObj;\r\n};\r\n\r\n#endif                                 /* struct_tag_qrLkTWTW64zZK0sqwALTyG */\r\n\r\n#ifndef typedef_codertarget_arduinobase_blocks_T\r\n#define typedef_codertarget_arduinobase_blocks_T\r\n\r\ntypedef struct tag_qrLkTWTW64zZK0sqwALTyG codertarget_arduinobase_blocks_T;\r\n\r\n#endif                            /* typedef_codertarget_arduinobase_blocks_T */\r\n\r\n#ifndef struct_tag_hWgtZAPqSjs1EyhETh9jYH\r\n#define struct_tag_hWgtZAPqSjs1EyhETh9jYH\r\n\r\nstruct tag_hWgtZAPqSjs1EyhETh9jYH\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif                                 /* struct_tag_hWgtZAPqSjs1EyhETh9jYH */\r\n\r\n#ifndef typedef_comm_internal_RandomIntegerGen_T\r\n#define typedef_comm_internal_RandomIntegerGen_T\r\n\r\ntypedef struct tag_hWgtZAPqSjs1EyhETh9jYH comm_internal_RandomIntegerGen_T;\r\n\r\n#endif                            /* typedef_comm_internal_RandomIntegerGen_T */\r\n\r\n#ifndef struct_tag_jShWpKUOycwBMhFyiKcKhC\r\n#define struct_tag_jShWpKUOycwBMhFyiKcKhC\r\n\r\nstruct tag_jShWpKUOycwBMhFyiKcKhC\r\n{\r\n  int32_T isInitialized;\r\n  boolean_T TunablePropsChanged;\r\n};\r\n\r\n#endif                                 /* struct_tag_jShWpKUOycwBMhFyiKcKhC */\r\n\r\n#ifndef typedef_codertarget_arduinobase_inte_j_T\r\n#define typedef_codertarget_arduinobase_inte_j_T\r\n\r\ntypedef struct tag_jShWpKUOycwBMhFyiKcKhC codertarget_arduinobase_inte_j_T;\r\n\r\n#endif                            /* typedef_codertarget_arduinobase_inte_j_T */\r\n\r\n#ifndef struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n#define struct_tag_9aqKbsbsI7JI0RwgnVwU0C\r\n\r\nstruct tag_9aqKbsbsI7JI0RwgnVwU0C\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif                                 /* struct_tag_9aqKbsbsI7JI0RwgnVwU0C */\r\n\r\n#ifndef typedef_c_arduinodriver_ArduinoDigital_T\r\n#define typedef_c_arduinodriver_ArduinoDigital_T\r\n\r\ntypedef struct tag_9aqKbsbsI7JI0RwgnVwU0C c_arduinodriver_ArduinoDigital_T;\r\n\r\n#endif                            /* typedef_c_arduinodriver_ArduinoDigital_T */\r\n\r\n#ifndef struct_tag_mPMPiw8t0JZKYO8orfnwRG\r\n#define struct_tag_mPMPiw8t0JZKYO8orfnwRG\r\n\r\nstruct tag_mPMPiw8t0JZKYO8orfnwRG\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  c_arduinodriver_ArduinoDigital_T DigitalIODriverObj;\r\n  real_T SampleTime;\r\n};\r\n\r\n#endif                                 /* struct_tag_mPMPiw8t0JZKYO8orfnwRG */\r\n\r\n#ifndef typedef_codertarget_arduinobase_bloc_j_T\r\n#define typedef_codertarget_arduinobase_bloc_j_T\r\n\r\ntypedef struct tag_mPMPiw8t0JZKYO8orfnwRG codertarget_arduinobase_bloc_j_T;\r\n\r\n#endif                            /* typedef_codertarget_arduinobase_bloc_j_T */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_LineFollowing3_T_ P_LineFollowing3_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_LineFollowing3_T RT_MODEL_LineFollowing3_T;\r\n\r\n#endif                                 /* RTW_HEADER_LineFollowing3_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"LineFollowing3_data.c","type":"source","group":"data","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: LineFollowing3_data.c\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"LineFollowing3.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_LineFollowing3_T LineFollowing3_P = {\r\n  /* Variable: InputPWM\r\n   * Referenced by:\r\n   *   '<Root>/Left Motor LUT'\r\n   *   '<Root>/Left Motor LUT1'\r\n   */\r\n  { -127.0, -126.0, -125.0, -124.0, -123.0, -122.0, -121.0, -120.0, -119.0,\r\n    -118.0, -117.0, -116.0, -115.0, -114.0, -113.0, -112.0, -111.0, -110.0,\r\n    -109.0, -108.0, -107.0, -106.0, -105.0, -104.0, -103.0, -102.0, -101.0,\r\n    -100.0, -99.0, -98.0, -97.0, -96.0, -95.0, -94.0, -93.0, -92.0, -91.0, -90.0,\r\n    -89.0, -88.0, -87.0, -86.0, -85.0, -84.0, -83.0, -82.0, -81.0, -80.0, -79.0,\r\n    -78.0, -77.0, -76.0, -75.0, -74.0, -73.0, -72.0, -71.0, -70.0, -69.0, -68.0,\r\n    -67.0, -66.0, -65.0, -64.0, -63.0, -62.0, -61.0, -60.0, -59.0, -58.0, -57.0,\r\n    -56.0, -55.0, -54.0, -53.0, -52.0, -51.0, -50.0, -49.0, -48.0, -47.0, -46.0,\r\n    -45.0, -44.0, -43.0, -42.0, 0.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0,\r\n    49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0,\r\n    62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0,\r\n    75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0,\r\n    88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0,\r\n    100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0,\r\n    111.0, 112.0, 113.0, 114.0, 115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0,\r\n    122.0, 123.0, 124.0, 125.0, 126.0, 127.0 },\r\n\r\n  /* Variable: WheelSpeed\r\n   * Referenced by:\r\n   *   '<Root>/Left Motor LUT'\r\n   *   '<Root>/Left Motor LUT1'\r\n   */\r\n  { -12.5105278523077, -12.3751973907692, -12.2398669292308, -12.1045364676923,\r\n    -11.9692060061538, -11.8338755446154, -11.6985450830769, -11.5632146215385,\r\n    -11.42788416, -11.2925536984615, -11.1572232369231, -11.0218927753846,\r\n    -10.8865623138461, -10.7512318523077, -10.6159013907692, -10.4805709292308,\r\n    -10.3452404676923, -10.2099100061538, -10.0745795446154, -9.93924908307692,\r\n    -9.80391862153846, -9.66858816, -9.53325769846154, -9.39792723692308,\r\n    -9.26259677538462, -9.12726631384615, -8.99193585230769, -8.85660539076923,\r\n    -8.72127492923077, -8.58594446769231, -8.45061400615385, -8.31528354461539,\r\n    -8.17995308307692, -8.04462262153846, -7.90929216, -7.77396169846154,\r\n    -7.63863123692308, -7.50330077538462, -7.36797031384615, -7.23263985230769,\r\n    -7.09730939076923, -6.96197892923077, -6.82664846769231, -6.69131800615385,\r\n    -6.55598754461539, -6.42065708307692, -6.28532662153846, -6.14999616,\r\n    -6.01466569846154, -5.87933523692308, -5.74400477538462, -5.60867431384616,\r\n    -5.47334385230769, -5.33801339076923, -5.20268292923077, -5.06735246769231,\r\n    -4.93202200615385, -4.79669154461538, -4.66136108307692, -4.52603062153846,\r\n    -4.39070016, -4.303992, -4.178328, -4.021248, -3.8327519999999997,\r\n    -3.6442559999999995, -3.518592, -3.4557599999999997, -3.3300959999999997,\r\n    -3.204432, -3.015936, -2.890272, -2.7646079999999995, -2.576112, -2.51328,\r\n    -2.3562, -2.1677039999999996, -2.1362879999999995, -1.9163759999999999,\r\n    -1.790712, -1.633632, -1.5708, -1.445136, -1.3508879999999999,\r\n    -1.1623919999999999, -1.005312, 0.0, 1.005312, 1.1623919999999999,\r\n    1.3508879999999999, 1.445136, 1.5708, 1.633632, 1.790712, 1.9163759999999999,\r\n    2.1362879999999995, 2.1677039999999996, 2.3562, 2.51328, 2.576112,\r\n    2.7646079999999995, 2.890272, 3.015936, 3.204432, 3.3300959999999997,\r\n    3.4557599999999997, 3.518592, 3.6442559999999995, 3.8327519999999997,\r\n    4.021248, 4.178328, 4.303992, 4.39070016, 4.52603062153846, 4.66136108307692,\r\n    4.79669154461538, 4.93202200615384, 5.06735246769231, 5.20268292923077,\r\n    5.33801339076923, 5.47334385230769, 5.60867431384615, 5.74400477538461,\r\n    5.87933523692307, 6.01466569846154, 6.14999616, 6.28532662153846,\r\n    6.42065708307692, 6.55598754461538, 6.69131800615384, 6.8266484676923,\r\n    6.96197892923077, 7.09730939076923, 7.23263985230769, 7.36797031384615,\r\n    7.50330077538461, 7.63863123692307, 7.77396169846154, 7.90929216,\r\n    8.04462262153846, 8.17995308307692, 8.31528354461538, 8.45061400615384,\r\n    8.5859444676923, 8.72127492923077, 8.85660539076923, 8.99193585230769,\r\n    9.12726631384615, 9.26259677538461, 9.39792723692307, 9.53325769846153,\r\n    9.66858816, 9.80391862153846, 9.93924908307692, 10.0745795446154,\r\n    10.2099100061538, 10.3452404676923, 10.4805709292308, 10.6159013907692,\r\n    10.7512318523077, 10.8865623138462, 11.0218927753847, 11.1572232369231,\r\n    11.2925536984616, 11.42788416, 11.5632146215385, 11.698545083077,\r\n    11.8338755446154, 11.9692060061539, 12.1045364676923, 12.2398669292308,\r\n    12.3751973907693, 12.5105278523077 },\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant4'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Constant5'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<Root>/Constant2'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Constant3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0.1\r\n   * Referenced by: '<Root>/sense1'\r\n   */\r\n  0.1,\r\n\r\n  /* Expression: 0.1\r\n   * Referenced by: '<Root>/sense2'\r\n   */\r\n  0.1,\r\n\r\n  /* Expression: 0.1\r\n   * Referenced by: '<Root>/sense3'\r\n   */\r\n  0.1,\r\n\r\n  /* Expression: 0.1\r\n   * Referenced by: '<Root>/sense4'\r\n   */\r\n  0.1,\r\n\r\n  /* Expression: 1.1\r\n   * Referenced by: '<Root>/Gain'\r\n   */\r\n  1.1,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Switch1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Switch'\r\n   */\r\n  0.0\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtmodel.h\r\n *\r\n * Code generated for Simulink model 'LineFollowing3'.\r\n *\r\n * Model version                  : 5.33\r\n * Simulink Coder version         : 9.9 (R2023a) 19-Nov-2022\r\n * C/C++ source code generated on : Mon Oct  9 16:36:07 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"LineFollowing3.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"ArduinoPinHandleMap.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#include \"rtwtypes.h\"\n\n#define ANALOG_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \ntypedef uint8_T PeripheralHandleMapType;\nPeripheralHandleMapType analogPinHandleMap[(ANALOG_MODULES_MAX/8)+1] = {0};\nPeripheralHandleMapType PWMPinHandleMap[(PWM_MODULES_MAX/8)+1] = {0};\n\n#ifdef __cplusplus\n}\n#endif\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinotarget\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2022 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#ifdef ESP_PLATFORM\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if(defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if defined(_RTT_SPI_SSPIN_)\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n        #ifdef ESP_PLATFORM\n        WiFi.config(wifiLocalIpAddress, wifigateway, subnet, dns1, dns2);\n        #else\n        WiFi.config(wifiLocalIpAddress);\n        #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM)\n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        esp_wifi_sta_wpa2_ent_set_identity((uint8_t *)wpa2username, strlen(wpa2username)); //provide identity\n        esp_wifi_sta_wpa2_ent_set_username((uint8_t *)wpa2username, strlen(wpa2username)); //provide username --> identity and username is same\n        esp_wifi_sta_wpa2_ent_set_password((uint8_t *)wpa2password, strlen(wpa2password)); //provide password\n        esp_wpa2_config_t config = WPA2_CONFIG_INIT_DEFAULT(); //set config settings to default\n        esp_wifi_sta_wpa2_ent_enable(&config); //set config settings to enable function\n        configureSuccess = WiFi.begin(ssid); //connect to wifi\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM))\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if(defined(ESP_PLATFORM))\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        Serial.print(\"<<< IP address :\");\n        Serial.print(ip);\n        Serial.println(\" >>>\");\n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n\n    #endif /*Initialize wifi*/\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS)))\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif\n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_PWM.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2021 The MathWorks, Inc. */\n\n#include \"MW_PWM.h\"\n#include \"MW_PWMDriver.h\"\n\n#if (defined(ESP_PLATFORM))\n//#include \"soc/soc_caps.h\" This file is present in new core of esp32. Uncomment and remove SOC_GPIO_PIN_COUNT defination once esp32 core is updated\n#define SOC_GPIO_PIN_COUNT              40\n#endif\n\n#if !(( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) ))\n#include \"Arduino.h\"\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define PWM_MODULES_MAX 70  /* For Mega and Due. Other boards have less number of Modules */\n\n#if (defined(ARDUINO_ARDUINO_NANO33BLE))\nuint32_t nano33BLE_dutycycle[21];\nuint16_t nano33BLE_period[21];\n#endif\n\ntypedef uint8_T PeripheralHandleMapType;\nextern PeripheralHandleMapType PWMPinHandleMap[];     /* The array is defined in ArduinoPinHandleMap.cpp */\n\n/* For PWM SVd provides no function to get the handle */\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin);\nvoid setPWMHandle(uint32_T Pin, MW_Handle_Type handle);\n\n#if (defined(ESP_PLATFORM))\n#define ESP32_PWM_RESOLUTION            8\n#if (defined(_RTT_NUMSERVOS_) && (_RTT_NUMSERVOS_ != 0))\n#define LAST_CHAN (8)\n#else\n#define LAST_CHAN (16)\n#endif\nstatic int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = { 0 };\nstatic int channelCounter = LAST_CHAN;\n#endif\n\n/* PWM Initialisation selected by the pinNumber (PWM Channel) */\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T prescaler, real_T period)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    return NULL;\n    #else\n    #if (defined(ESP_PLATFORM))\n    if (pin < SOC_GPIO_PIN_COUNT) {\n        if (pin_to_channel[pin] == 0) {\n            if (!channelCounter) {\n                log_e(\"No more analogWrite channels available! You can have maximum %u\", LAST_CHAN);\n                return 0;\n            }\n            pinMode(pin,OUTPUT);\n            pin_to_channel[pin] = channelCounter ;\n            ledcAttachPin(pin, channelCounter-1);\n            if(prescaler == 0)                    // Default frequency\n            {\n                ledcSetup(channelCounter-1, ARDUINO_DEFAULT_PWM_FREQUENCY, ESP32_PWM_RESOLUTION);\n            }\n            else\n            {\n                ledcSetup(channelCounter-1, prescaler, ESP32_PWM_RESOLUTION);\n            }\n            #ifdef _RTT_PWM_CUSTOM_FREQUENCY_\n            channelCounter = channelCounter-2;    // Use only one channel from channel pair\n            #else\n            channelCounter = channelCounter-1;\n            #endif\n        }\n        ledcWrite(pin_to_channel[pin] - 1, 0);\n    }else{\n        return 0;\n    }\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n    return (MW_Handle_Type)(pin+1);\n    #else\n    pinMode(pin,OUTPUT);\n\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    nano33BLE_dutycycle[pin] = 0;\n    nano33BLE_period[pin] = 1000000/500;\n    #endif\n\n    /* handle is stored as Pin+1 because, to reset the handle of a pin, 0 is passed as handle. Otherwise it will create confusion for Pin number 0. */\n    setPWMHandle(pin, (MW_Handle_Type)(pin+1));\n\n    if(period>0) /*No initialization in case of Default frequnecy*/\n    {\n        MW_setAnalogFrequency(pin, prescaler,period);\n    }\n    return (MW_Handle_Type)(pin+1);\n    #endif\n    #endif\n}\n\n/* Start PWM */\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Set the duty cycle or pulse width for the PWM signal */\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    /* This will be run in Rapid Accelerator Mode */\n    (void)PWMPinHandle;\n    (void)dutyCycle;\n    return;\n    #else\n    #if (defined(ESP_PLATFORM))\n    uint8_T pin;\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(dutyCycle < 0)       /* Changed frequency */\n        {\n            dutyCycle = dutyCycle * -1;\n        }\n        ledcWrite(pin_to_channel[pin] - 1, dutyCycle);\n    }\n    #else\n    uint8_T pin;\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        if(dutyCycle < 0)       /* Changed frequency*/\n        {\n            dutyCycle = dutyCycle * -1;\n            MW_analogWrite(pin, dutyCycle);\n        }\n        else                    /* Default frequency*/\n        {\n            #if !(defined(ARDUINO_ARDUINO_NANO33BLE))\n            analogWrite(pin, dutyCycle);\n            #else\n            nano33BLE_period[pin] = 1000000/500; //Default frequency of 500Hz\n            nano33BLE_dutycycle[pin] = (dutyCycle* nano33BLE_period[pin]/255);\n            #endif\n        }\n    }\n    #endif\n    #endif\n}\n\n/* Set the PWM signal frequency */\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency)\n{\n    (void)PWMPinHandle;\n    (void)frequency;\n}\n\n/* Disable notifications on the channel */\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Enable notifications on the channel */\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification)\n{\n    (void)PWMPinHandle;\n    (void)Notification;\n}\n\n/* Set PWM output to idle state */\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Get the PWM output status */\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n    return 0;\n}\n\n/* Stop PWM */\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle)\n{\n    (void)PWMPinHandle;\n}\n\n/* Close PWM */\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /* If the PWM handle is 0 then do nothing. */\n    if(*((uint8_T*)(&PWMPinHandle)))\n    {\n        uint8_T pin = 0;\n        /* The handle of a Pin is stored as (Pin+1) */\n        pin =  *((uint8_T*)(&PWMPinHandle)) - 1;\n        setPWMHandle(pin, (MW_Handle_Type)0);\n    }\n    (void)PWMPinHandle;\n    #endif\n}\n\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return NULL;\n    #else\n    uint16_T ByteNo=0, handleValue=0;\n\n    uint8_T BitPositionNo=0;\n\n    ByteNo = Pin/8;\n    BitPositionNo = Pin%8;\n\n    handleValue = PWMPinHandleMap[ByteNo] & (PeripheralHandleMapType)(1<<BitPositionNo);\n\n    if(handleValue)\n    {\n        /*\n        Returns the value of the module if the pin is opened earlier\n        */\n        handleValue = Pin+1;\n        /*\n        This allows to differentiate between pin zero and a Null condition\n\n        Another option - return true, and then remove the decrement in the SVD of all functions in Arduino\n        */\n    }\n    else\n    {\n        handleValue = 0;\n    }\n    return (MW_Handle_Type)handleValue;\n    #endif\n}\n\nvoid setPWMHandle(uint32_T module, MW_Handle_Type handle)\n{\n    #if ( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n    return;\n    #else\n    /*\n    Assumes pin number from count zero\n    */\n    uint16_T ByteNo=0;\n    uint8_T BitPositionNo=0;\n    PeripheralHandleMapType tempVar=0;\n    /*\n    Integer division rounds off to value providing the abs byte no\n    */\n    ByteNo = module/8;\n    BitPositionNo = module%8;\n\n    tempVar = (1<<BitPositionNo);\n    /*\n    The assumption is module number is the handle,\n    but when handle is Null, reset the handle\n    */\n    if(!handle)\n    {\n        /*reset the handle*/\n        tempVar = ~tempVar;\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] & tempVar;\n    }\n    else\n    {\n        /*set the handle*/\n        PWMPinHandleMap[ByteNo] = PWMPinHandleMap[ByteNo] | tempVar;\n    }\n    #endif\n}\n\n#ifdef __cplusplus\n}\n#endif\n#else\nMW_Handle_Type MW_PWM_Open(uint32_T pin, real_T frequency, real_T dutyCycle){return 0;}\nvoid MW_PWM_Start(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_SetDutyCycle(MW_Handle_Type PWMPinHandle, real_T dutyCycle){}\nvoid MW_PWM_SetFrequency(MW_Handle_Type PWMPinHandle, real_T frequency){}\nvoid MW_PWM_DisableNotification(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_EnableNotification(MW_Handle_Type PWMPinHandle, MW_PWM_EdgeNotification_Type Notification){}\nvoid MW_PWM_SetOutputToIdle(MW_Handle_Type PWMPinHandle){}\nboolean_T MW_PWM_GetOutputState(MW_Handle_Type PWMPinHandle){return 0;}\nvoid MW_PWM_Stop(MW_Handle_Type PWMPinHandle){}\nvoid MW_PWM_Close(MW_Handle_Type PWMPinHandle){}\nMW_Handle_Type MW_PWM_GetHandle(uint32_T Pin){return 0;}\n#endif\n"},{"name":"MW_PWMDriver.c","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Code to configure Timer and set duty cycle\n * This file is modified version of wiring_analog.c file\n * It separates analogWrite function into two parts:\n * 1. MW_setAnalogFrequency: This function initializes PWM peripheral\n * 2. MW_analogWrite: This function sets the duty cycle\n * /* Copyright 2019 The MathWorks, Inc. */\n\n#include \"MW_PWMDriver.h\"\n\n#if !( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n\n#if defined(ARDUINO_ARCH_SAMD)                                                          /* SAMD Targets */\n#include \"Arduino.h\"\n#include \"wiring_private.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncDAC() __attribute__((always_inline, unused));\nstatic void syncDAC() {\n  while (DAC->STATUS.bit.SYNCBUSY == 1)\n    ;\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTC_8(Tc* TCx) __attribute__((always_inline, unused));\nstatic void syncTC_8(Tc* TCx) {\n  while (TCx->COUNT8.STATUS.bit.SYNCBUSY);\n}\n\n// Wait for synchronization of registers between the clock domains\nstatic __inline__ void syncTCC(Tcc* TCCx) __attribute__((always_inline, unused));\nstatic void syncTCC(Tcc* TCCx) {\n  while (TCCx->SYNCBUSY.reg & TCC_SYNCBUSY_MASK);\n}\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG)\n  {\n    // DAC handling code\n\n    if ((pinDesc.ulADCChannelNumber != ADC_Channel0) && (pinDesc.ulADCChannelNumber != DAC_Channel0)) { // Only 1 DAC on AIN0 / PA02\n      return;\n    }\n\n    value = mapResolution(value, _writeResolution, 10);\n\n    syncDAC();\n    DAC->DATA.reg = value & 0x3FF;  // DAC on 10 bits.\n    syncDAC();\n    DAC->CTRLA.bit.ENABLE = 0x01;     // Enable DAC\n    syncDAC();\n    return;\n  }\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    \n    if (tcNum >= TCC_INST_NUM) {\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n    } else {\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        TCCx->CTRLBSET.bit.LUPD = 1;\n        syncTCC(TCCx);\n        TCCx->CCB[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        TCCx->CTRLBCLR.bit.LUPD = 1;\n        syncTCC(TCCx);\n    }\n    return;\n  }\n\n  // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n  uint32_t value = 0;                 //TODO: Get this value from caller\n  PinDescription pinDesc = g_APinDescription[pin];\n  uint32_t attr = pinDesc.ulPinAttribute;\n\n  if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM)\n  {\n    //value = mapResolution(value, _writeResolution, 16);\n    uint32_t tcNum = GetTCNumber(pinDesc.ulPWMChannel);\n    uint8_t tcChannel = GetTCChannelNumber(pinDesc.ulPWMChannel);\n    static bool tcEnabled[TCC_INST_NUM+TC_INST_NUM];\n\n    if (attr & PIN_ATTR_TIMER) {\n      #if !(ARDUINO_SAMD_VARIANT_COMPLIANCE >= 10603)\n      // Compatibility for cores based on SAMD core <=1.6.2\n      if (pinDesc.ulPinType == PIO_TIMER_ALT) {\n        pinPeripheral(pin, PIO_TIMER_ALT);\n      } else\n      #endif\n      {\n        pinPeripheral(pin, PIO_TIMER);\n      }\n    } else {\n      // We suppose that attr has PIN_ATTR_TIMER_ALT bit set...\n      pinPeripheral(pin, PIO_TIMER_ALT);\n    }\n\n    if (!tcEnabled[tcNum]) {\n      tcEnabled[tcNum] = true;\n\n      uint16_t GCLK_CLKCTRL_IDs[] = {\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC0\n        GCLK_CLKCTRL_ID(GCM_TCC0_TCC1), // TCC1\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TCC2\n        GCLK_CLKCTRL_ID(GCM_TCC2_TC3),  // TC3\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC4\n        GCLK_CLKCTRL_ID(GCM_TC4_TC5),   // TC5\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC6\n        GCLK_CLKCTRL_ID(GCM_TC6_TC7),   // TC7\n      };\n      GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_IDs[tcNum]);\n      while (GCLK->STATUS.bit.SYNCBUSY == 1);\n\n      // Set PORT\n      if (tcNum >= TCC_INST_NUM) {\n        // -- Configure TC\n        Tc* TCx = (Tc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 0;\n        syncTC_8(TCx);\n        // Set Timer counter Mode to 16 bits, normal PWM\n        TCx->COUNT8.CTRLA.reg |= TC_CTRLA_MODE_COUNT8 | TC_CTRLA_WAVEGEN_NPWM | (prescaler<<8);\n        syncTC_8(TCx);\n        // Set the initial value\n        TCx->COUNT8.CC[tcChannel].reg = (uint32_t) value;\n        syncTC_8(TCx);\n        TCx->COUNT8.PER.reg = period - 1;\n        syncTC_8(TCx);\n        // Enable TCx\n        TCx->COUNT8.CTRLA.bit.ENABLE = 1;\n        syncTC_8(TCx);\n      } else {\n        // -- Configure TCC\n        Tcc* TCCx = (Tcc*) GetTC(pinDesc.ulPWMChannel);\n        // Disable TCCx\n        TCCx->CTRLA.bit.ENABLE = 0;\n        syncTCC(TCCx);\n        // Prescaler\n        TCCx->CTRLA.reg |= (prescaler<<8);\n        syncTCC(TCCx);\n        // Set TCCx as normal PWM\n        TCCx->WAVE.reg |= TCC_WAVE_WAVEGEN_NPWM;\n        syncTCC(TCCx);\n        // Set the initial value\n        TCCx->CC[tcChannel].reg = (uint32_t) value;\n        syncTCC(TCCx);\n        // Set PER to maximum counter value (resolution : 0xFFFF)\n        TCCx->PER.reg = period - 1;\n        syncTCC(TCCx);\n        // Enable TCCx\n        TCCx->CTRLA.bit.ENABLE = 1;\n        syncTCC(TCCx);\n      }\n    }\n    return;\n  }\n    // -- Defaults to digital write\n  pinMode(pin, OUTPUT);\n  value = mapResolution(value, _writeResolution, 8);\n  if (value < 128) {\n    digitalWrite(pin, LOW);\n  } else {\n    digitalWrite(pin, HIGH);\n  }\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"Arduino.h\"\n#include \"pins_arduino.h\"\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic int _writeResolution = 8;\n\nextern uint32_t nano33BLE_dutycycle[21];\nextern uint16_t nano33BLE_period[21];\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to)\n{\n  if (from == to) {\n    return value;\n  }\n  if (from > to) {\n    return value >> (from-to);\n  }\n  return value << (to-from);\n}\n\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n  nano33BLE_dutycycle[pin] = value;\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    nano33BLE_period[pin] = period;\n}\n   \n#ifdef __cplusplus\n}\n#endif\n#elif defined(ARDUINO_ARCH_AVR)                                                         /* AVR Targets */\n#include \"wiring_private.h\"\n#include \"pins_arduino.h\"\nvoid MW_analogWrite(uint32_t pin, uint32_t value)\n{\n    analogWrite(pin, value);\n}\n\nvoid MW_setAnalogFrequency(uint16_t pin,uint16_t prescaler,uint16_t period)\n{\n    switch(digitalPinToTimer(pin))\n    {\n        // XXX fix needed for atmega8\n        #if defined(TCCR0) && defined(COM00) && !defined(__AVR_ATmega8__)\n        case TIMER0A:\n            // connect pwm to pin on timer 0\n            sbi(TCCR0, COM00);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0A1)\n        case TIMER0A:\n            // connect pwm to pin on timer 0, channel A\n            sbi(TCCR0A, COM0A1);\n            break;\n        #endif\n\n        #if defined(TCCR0A) && defined(COM0B1)\n        case TIMER0B:\n            // connect pwm to pin on timer 0, channel B\n            sbi(TCCR0A, COM0B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1A1)\n        case TIMER1A:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1A1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1B1)\n        case TIMER1B:\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1B1);\n            break;\n        #endif\n\n        #if defined(TCCR1A) && defined(TCCR1B) && defined(ICR1) && defined(COM1C1)\n        case TIMER1C:\n            // connect pwm to pin on timer 1, channel B\n            TCCR1A = (TCCR1A & 0xFCU) | 2U;                               //WGM11 for PWM, Phase Correct. Mode 10\n            TCCR1B = (TCCR1B & 0xE0U) | 0x10U | prescaler;                //WGM13 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR1   = period;                                              //Period\n            sbi(TCCR1A, COM1C1);\n            break;\n        #endif\n\n        #if defined(TCCR2) && defined(COM21)\n        case TIMER2:\n            // connect pwm to pin on timer 2\n            sbi(TCCR2, COM21);\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2A1)\n        case TIMER2A:\n            // connect pwm to pin on timer 2, channel A\n            sbi(TCCR2A, COM2A1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR2A) && defined(TCCR2B) && defined(COM2B1)\n        case TIMER2B:\n            // connect pwm to pin on timer 2, channel B\n            sbi(TCCR2A, COM2B1);\n            TCCR2B=TCCR2B & 0b11111000 | prescaler;                 //Prescaler\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3A1)\n        case TIMER3A:\n            // connect pwm to pin on timer 3, channel A\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3A1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3B1)\n        case TIMER3B:\n            // connect pwm to pin on timer 3, channel B\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3B1);\n            break;\n        #endif\n\n        #if defined(TCCR3A) && defined(TCCR3B) && defined(ICR3) && defined(COM3C1)\n        case TIMER3C:\n            // connect pwm to pin on timer 3, channel C\n            TCCR3A = (TCCR3A & 0xFCU) | 2U;                               //WGM31 for PWM, Phase Correct. Mode 10\n            TCCR3B = (TCCR3B & 0xE0U) | 0x10U | prescaler;                //WGM33 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR3   = period;                                              //Period\n            sbi(TCCR3A, COM3C1);\n            break;\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4A1) && defined(COM4A0)/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4A:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4A1);\n            cbi(TCCR4A, COM4A0);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4A1)\n        case TIMER4A:\n            //connect pwm to pin on timer 4, channel A\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4A1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4B1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4B:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4B1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4B1)    \n        case TIMER4B:\n            // connect pwm to pin on timer 4, channel B\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4B1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4C1) /* beginning of timer4 block for 32U4 and similar */\n        case TIMER4C:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            sbi(TCCR4A, COM4C1);\n            break;\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(ICR4) && defined(COM4C1)    \n        case TIMER4C:\n            // connect pwm to pin on timer 4, channel C\n            TCCR4A = (TCCR4A & 0xFCU) | 2U;                               //WGM41 for PWM, Phase Correct. Mode 10\n            TCCR4B = (TCCR4B & 0xE0U) | 0x10U | prescaler;                //WGM43 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR4   = period;                                              //Period\n            sbi(TCCR4A, COM4C1);\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D)  && defined(COM4D1) && defined(COM4D0)\t/* beginning of timer4 block for 32U4 and similar */\n        case TIMER4D:\n            TCCR4B = (TCCR4B & 0xf0) | prescaler;\n            OCR4C = period;\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            cbi(TCCR4C, COM4D0);\n        #else /* beginning of timer4 block for ATMEGA1280 and ATMEGA2560 */\n        #if defined(TCCR4C) && defined(COM4D1)\n        case TIMER4D:\t\t\t\t\n            // connect pwm to pin on timer 4, channel D\n            sbi(TCCR4C, COM4D1);\n            #if defined(COM4D0)\t\t// only used on 32U4\n            cbi(TCCR4C, COM4D0);\n            #endif\n            break;\n        #endif\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5A1)\n        case TIMER5A:\n            // connect pwm to pin on timer 5, channel A\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5A1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5B1)\n        case TIMER5B:\n            // connect pwm to pin on timer 5, channel B\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5B1);\n            break;\n        #endif\n\n        #if defined(TCCR5A) && defined(TCCR5B) && defined(ICR5) && defined(COM5C1)\n        case TIMER5C:\n            // connect pwm to pin on timer 5, channel C\n            TCCR5A = (TCCR5A & 0xFCU) | 2U;                               //WGM51 for PWM, Phase Correct. Mode 10\n            TCCR5B = (TCCR5B & 0xE0U) | 0x10U | prescaler;                //WGM53 for PWM, Phase Correct. Mode 10\n                                                                          //and prescaler\n            ICR5   = period;                                              //Period\n            sbi(TCCR5A, COM5C1);\n            break;\n        #endif\n    }\n    digitalWrite(pin, LOW);\n}\n\n#elif defined(ARDUINO_ARCH_SAM)                                                         /* SAM Targets */\n#include \"Arduino.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n    \nstatic int _writeResolution = 8;\nstatic uint8_t PWMEnabled = 0;\nstatic uint8_t TCChanEnabled[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};\n\nstatic inline uint32_t mapResolution(uint32_t value, uint32_t from, uint32_t to) {\n\tif (from == to)\n\t\treturn value;\n\tif (from > to)\n\t\treturn value >> (from-to);\n\telse\n\t\treturn value << (to-from);\n}\n\nstatic void TC_SetCMR_ChannelA(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xFFF0FFFF) | v;\n}\n\nstatic void TC_SetCMR_ChannelB(Tc *tc, uint32_t chan, uint32_t v)\n{\n\ttc->TC_CHANNEL[chan].TC_CMR = (tc->TC_CHANNEL[chan].TC_CMR & 0xF0FFFFFF) | v;\n}\n\nvoid MW_analogWrite(uint32_t ulPin, uint32_t ulValue)\n{\n\tuint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n\n\tif ((attr & PIN_ATTR_ANALOG) == PIN_ATTR_ANALOG) {\n\t\tEAnalogChannel channel = g_APinDescription[ulPin].ulADCChannelNumber;\n\t\tif (channel == DA0 || channel == DA1) {\n\t\t\tuint32_t chDACC = ((channel == DA0) ? 0 : 1);\n\t\t\tif (dacc_get_channel_status(DACC_INTERFACE) == 0) {\n\t\t\t\t/* Enable clock for DACC_INTERFACE */\n\t\t\t\tpmc_enable_periph_clk(DACC_INTERFACE_ID);\n\n\t\t\t\t/* Reset DACC registers */\n\t\t\t\tdacc_reset(DACC_INTERFACE);\n\n\t\t\t\t/* Half word transfer mode */\n\t\t\t\tdacc_set_transfer_mode(DACC_INTERFACE, 0);\n\n\t\t\t\t/* Power save:\n\t\t\t\t * sleep mode  - 0 (disabled)\n\t\t\t\t * fast wakeup - 0 (disabled)\n\t\t\t\t */\n\t\t\t\tdacc_set_power_save(DACC_INTERFACE, 0, 0);\n\t\t\t\t/* Timing:\n\t\t\t\t * refresh        - 0x08 (1024*8 dacc clocks)\n\t\t\t\t * max speed mode -    0 (disabled)\n\t\t\t\t * startup time   - 0x10 (1024 dacc clocks)\n\t\t\t\t */\n\t\t\t\tdacc_set_timing(DACC_INTERFACE, 0x08, 0, 0x10);\n\n\t\t\t\t/* Set up analog current */\n\t\t\t\tdacc_set_analog_control(DACC_INTERFACE, DACC_ACR_IBCTLCH0(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLCH1(0x02) |\n\t\t\t\t\t\t\t\t\t\t\tDACC_ACR_IBCTLDACCORE(0x01));\n\t\t\t}\n\n\t\t\t/* Disable TAG and select output channel chDACC */\n\t\t\tdacc_set_channel_selection(DACC_INTERFACE, chDACC);\n\n\t\t\tif ((dacc_get_channel_status(DACC_INTERFACE) & (1 << chDACC)) == 0) {\n\t\t\t\tdacc_enable_channel(DACC_INTERFACE, chDACC);\n\t\t\t}\n\n\t\t\t// Write user value\n\t\t\tulValue = mapResolution(ulValue, _writeResolution, DACC_RESOLUTION);\n\t\t\tdacc_write_conversion_data(DACC_INTERFACE, ulValue);\n\t\t\twhile ((dacc_get_interrupt_status(DACC_INTERFACE) & DACC_ISR_EOC) == 0);\n\t\t\treturn;\n\t\t}\n\t}\n    \n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n        uint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\t//ulValue = mapResolution(ulValue, _writeResolution, PWM_RESOLUTION);\n\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, ulValue);\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (ulValue == 0) {\n\t\t\tif (chA)\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR);\n\t\t\telse\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t} else {\n\t\t\tif (chA) {\n\t\t\t\tTC_SetRA(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelA(chTC, chNo, TC_CMR_ACPA_CLEAR | TC_CMR_ACPC_SET);\n\t\t\t} else {\n\t\t\t\tTC_SetRB(chTC, chNo, ulValue);\n\t\t\t\tTC_SetCMR_ChannelB(chTC, chNo, TC_CMR_BCPB_CLEAR | TC_CMR_BCPC_SET);\n\t\t\t}\n\t\t}\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\t// Defaults to digital write\n\tpinMode(ulPin, OUTPUT);\n\tulValue = mapResolution(ulValue, _writeResolution, 8);\n\tif (ulValue < 128)\n\t\tdigitalWrite(ulPin, LOW);\n\telse\n\t\tdigitalWrite(ulPin, HIGH);\n}\nvoid MW_setAnalogFrequency(uint16_t ulPin,uint16_t prescaler,uint16_t period)\n{\n    uint32_t attr = g_APinDescription[ulPin].ulPinAttribute;\n    if ((attr & PIN_ATTR_PWM) == PIN_ATTR_PWM) {\n\t\tif (!PWMEnabled) {\n\t\t\t// PWM Startup code\n\t\t    pmc_enable_periph_clk(PWM_INTERFACE_ID);\n\t\t    PWMC_ConfigureClocks(PWM_FREQUENCY * PWM_MAX_DUTY_CYCLE, 0, VARIANT_MCK);\n\t\t\tPWMEnabled = 1;\n\t\t}\n\n\t\tuint32_t chan = g_APinDescription[ulPin].ulPWMChannel;\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\t// Setup PWM for this pin\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tPWMC_ConfigureChannel(PWM_INTERFACE, chan, prescaler, 0, 0);\n\t\t\tPWMC_SetPeriod(PWM_INTERFACE, chan, period);\n\t\t\tPWMC_SetDutyCycle(PWM_INTERFACE, chan, 0);\n\t\t\tPWMC_EnableChannel(PWM_INTERFACE, chan);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\treturn;\n\t}\n\n\tif ((attr & PIN_ATTR_TIMER) == PIN_ATTR_TIMER) {\n\t\t// We use MCLK/2 as clock.\n\t\tconst uint32_t TC = period;\n\n\t\t// Setup Timer for this pin\n\t\tETCChannel channel = g_APinDescription[ulPin].ulTCChannel;\n\t\tstatic const uint32_t channelToChNo[] = { 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2 };\n\t\tstatic const uint32_t channelToAB[]   = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0 };\n\t\tstatic Tc *channelToTC[] = {\n\t\t\tTC0, TC0, TC0, TC0, TC0, TC0,\n\t\t\tTC1, TC1, TC1, TC1, TC1, TC1,\n\t\t\tTC2, TC2, TC2, TC2, TC2, TC2 };\n\t\tstatic const uint32_t channelToId[] = { 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8 };\n\t\tuint32_t chNo = channelToChNo[channel];\n\t\tuint32_t chA  = channelToAB[channel];\n\t\tTc *chTC = channelToTC[channel];\n\t\tuint32_t interfaceID = channelToId[channel];\n\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tpmc_enable_periph_clk(TC_INTERFACE_ID + interfaceID);\n\t\t\tTC_Configure(chTC, chNo,\n\t\t\t\tprescaler |\n\t\t\t\tTC_CMR_WAVE |         // Waveform mode\n\t\t\t\tTC_CMR_WAVSEL_UP_RC | // Counter running up and reset when equals to RC\n\t\t\t\tTC_CMR_EEVT_XC0 |     // Set external events from XC0 (this setup TIOB as output)\n\t\t\t\tTC_CMR_ACPA_CLEAR | TC_CMR_ACPC_CLEAR |\n\t\t\t\tTC_CMR_BCPB_CLEAR | TC_CMR_BCPC_CLEAR);\n\t\t\tTC_SetRC(chTC, chNo, TC);\n\t\t}\n\t\t\n\t\tif ((g_pinStatus[ulPin] & 0xF) != PIN_STATUS_PWM) {\n\t\t\tPIO_Configure(g_APinDescription[ulPin].pPort,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinType,\n\t\t\t\t\tg_APinDescription[ulPin].ulPin,\n\t\t\t\t\tg_APinDescription[ulPin].ulPinConfiguration);\n\t\t\tg_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_PWM;\n\t\t}\n\t\tif (!TCChanEnabled[interfaceID]) {\n\t\t\tTC_Start(chTC, chNo);\n\t\t\tTCChanEnabled[interfaceID] = 1;\n\t\t}\n\t\treturn;\n\t}\n}\n\n#ifdef __cplusplus\n}\n#endif\n#endif                                                                                  /* Architecture selection endif*/                                                                             \n\n#endif /*Rapid Accel condition check*/\n/* [EOF] */"},{"name":"MW_Ultrasonic.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Wrappers to make Ultrasonic sensor functions available with C linkage. \n * This allows C++ methods to be called from C code.\n *\n/* Copyright 2018 The MathWorks, Inc. */\n#include \"MW_Ultrasonic.h\"\n#if !( defined(MATLAB_MEX_FILE) || defined(RSIM_PARAMETER_LOADING) ||  defined(RSIM_WITH_SL_SOLVER) )\n\n    #include <Arduino.h>\n    #define PULSE_LOW_TIME 5\n\n    extern \"C\" {\n            void __cxa_pure_virtual(void);\n    }\n\n    /* Ultrasonic sensor initialization */\n    /* Called only for sensors having both Trigger and Echo pins*/\n    extern \"C\" void MW_UltrasonicSetup(uint8_T TrigPin, uint8_T EchoPin) \n    {   \n        /*Set mode for Trigger and Echo Pins*/\n        pinMode(TrigPin, OUTPUT);\n        pinMode(EchoPin, INPUT);\n    }\n\n    /* Get the duration from Ultrasonic sensor */\n    extern \"C\" void MW_UltrasonicRead(uint32_T *duration, uint8_T hasTrig, uint8_T TrigPin, uint8_T EchoPin, uint8_T Trigger_Pulse_Duration)\n    {\n        unsigned long startTime;\n        /* Both TrigPin and EchoPin are same as SignalPin for sensors \n         * having 1 signal pin*/\n        if (!hasTrig) {\n           /*Set Signal Pin to Output for sensors having 1 signal pin\n            * before sending Trigger*/\n            pinMode(TrigPin, OUTPUT);       \n        } \n        /*Send Trigger*/\n        digitalWrite(TrigPin, LOW);\n        startTime = micros();\n        while(micros() - startTime <= PULSE_LOW_TIME){\n        }\n\n        digitalWrite(TrigPin, HIGH);\n        startTime = micros();\n        while(micros() - startTime <= Trigger_Pulse_Duration){\n        }\n        digitalWrite(TrigPin, LOW);\n\n        if (!hasTrig) {\n            /*Set Signal Pin to Input for sensors having 1 signal pin \n             * to read incoming echo*/\n            pinMode(EchoPin, INPUT);\n        } \n        \n        /* Read Echo duration*/\n        *duration = pulseIn(EchoPin, HIGH);\n    }\n\n#endif /*Rapid Accel condition check*/\n/* [EOF] */"},{"name":"MW_arduino_digitalio.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"#ifndef MATLAB_MEX_FILE\n#include <Arduino.h>\n#include \"MW_arduino_digitalio.h\"\n#endif\n#include \"rtwtypes.h\"\n\n// Digital I/O initialization\nextern \"C\" void digitalIOSetup(uint8_T pin, uint8_T mode) \n{ \n    #ifndef MATLAB_MEX_FILE\n    // mode = 0: Input\n    // mode = 1: Output\n    // mode = 2: Input pullup\n    if (mode==0) {\n        pinMode(pin, INPUT);\n    }\n    else if (mode==1) {\n        pinMode(pin, OUTPUT);\n    }\n    else {\n        // mode = 2 is for input pullup\n        pinMode(pin, INPUT_PULLUP);\n    }\n    #endif\n}\n\n// Write a logic value to pin\nextern \"C\" void writeDigitalPin(uint8_T pin, boolean_T val)\n{\n    #ifndef MATLAB_MEX_FILE\n    if (val) {\n        digitalWrite(pin, HIGH);\n    } \n    else {\n        digitalWrite(pin, LOW);\n    }\n    #endif\n}\n\n// Read logical state of a digital pin\nextern \"C\" boolean_T readDigitalPin(uint8_T pin)\n{\n    #ifndef MATLAB_MEX_FILE\n    boolean_T ret;\n     \n    ret = (digitalRead(pin) == HIGH) ? 1:0;\n    return ret;\n    #else\n    return (boolean_T)0;\n    #endif\n}\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 0\n#include \"MW_ArduinoHWInit.h\"\n#include \"arduinoARM_M0plusScheduler.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Arduino Nano 33 IoT\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 921600\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BOOTLOADER_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BOOTLOADER_COMPORT_SPECIFY 2\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_PIL_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SPECIFY 1\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD 0\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD_SPECIFY \n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 6\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_SERIAL_SERIAL1_BAUD_RATE 8\n#define MW_SERIAL_SERIAL1_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL1_CONFIG 3\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_SPI_SPI_CLOCK_OUT_FREQUENCY 2\n#define MW_SPI_SPI_MODE 0\n#define MW_SPI_SPI_BITORDER 0\n#define MW_SPI_SDSLAVESELECT 4.000000\n#define MW_SPI_CANCHIPSELECT 3.000000\n#define MW_WIFI_DISABLE_DHCP_WIFI 0\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_WIFI_WPA2_USERNAME username\n#define MW_WIFI_WIFI_WPA2_PASSWORD password\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 2.000000\n#define MW_CAN_ALLOWALLFILTER 0\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER0_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER1_NOR 255\n#define MW_CAN_ACCEPTANCEMASK0_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER0_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER1_EXT 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER2_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER3_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER4_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER5_NOR 255\n#define MW_CAN_ACCEPTANCEMASK1_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER2_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER3_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER4_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER5_EXT 255\n#define MW_MODBUS_MODBUS_COMMS 0\n#define MW_MODBUS_MODBUS_MODE 0\n#define MW_MODBUS_MODBUS_SLAVEID 1\n#define MW_MODBUS_MODBUS_CONFIGCOIL 49\n#define MW_MODBUS_MODBUS_COILADDR 0\n#define MW_MODBUS_MODBUS_COILNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUT 49\n#define MW_MODBUS_MODBUS_INPUTADDR 0\n#define MW_MODBUS_MODBUS_INPUTNUM 1\n#define MW_MODBUS_MODBUS_CONFIGHOLDINGREG 49\n#define MW_MODBUS_MODBUS_HOLDINGREGADDR 0\n#define MW_MODBUS_MODBUS_HOLDINGREGNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUTREG 49\n#define MW_MODBUS_MODBUS_INPUTREGADDR 0\n#define MW_MODBUS_MODBUS_INPUTREGNUM 1\n#define MW_MODBUS_MODBUS_MASTERTIMEOUT 100\n#define MW_RS485_RS485_SERIAL 0\n#define MW_RS485_RS485_BAUD 9600\n#define MW_RS485_RS485_CONFIG 3\n#define MW_RS485_RS485_DEPIN 8\n#define MW_RS485_RS485_REPIN 9\n#define MW_DISPLAY_ENABLECODEGEN 0\n#define MW_DISPLAY_APPLAUNCHBUTTON \n#define MW_BLE_PERIPHERAL_DEVICE_NAME Arduino\n#define MW_BLE_PERIPHERAL_LOCAL_NAME Arduino\n#define MW_BLE_ADVERTISING_INTERVAL 160\n#define MW_BLE_MIN_CONNECTION_INTERVAL 6\n#define MW_BLE_MAX_CONNECTION_INTERVAL 3200\n#define MW_MQTT_BROKERSERVICE 0\n#define MW_MQTT_BROKERADDRESS mqtt3.thingspeak.com\n#define MW_MQTT_BROKERPORT 1883\n#define MW_MQTT_USERNAME \n#define MW_MQTT_PASSWORD \n#define MW_MQTT_CLIENTID \n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n#define MW_DASHBOARDCODEGENINFO_ENABLECODEGEN 0\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.circularGauge\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.lcdTextDisplay\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.pushButton\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"arduinoARM_M0plusScheduler.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinotarget\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino ARM M0+ Bareboard scheduler\n *\n * Copyright 2017-2021 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoARM_M0plusScheduler.h\"\n#include \"Reset.h\"\n/* Multi tasking related header file */\n\n#include \"arm_cortex_m_multitasking.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\n#if (defined(MW_SCHEDULERCOUNTER) &&  (MW_SCHEDULERCOUNTER > 1))\n   #if (MW_SCHEDULERCOUNTER >= 65536)\n      volatile uint32_t scheduler_counter = 0;\n    #elif (MW_SCHEDULERCOUNTER >= 256)\n      volatile uint16_t scheduler_counter = 0;\n    #else\n      volatile uint8_t scheduler_counter = 0;\n    #endif\n#endif\n\n/*\n * Call the rt_Onestep function when the timer interrupt hits     \n *\n */\nstatic void Scheduler_Isr(void)\n{\n    DISABLE_SCHEDULER_INT();\n    \n    \n    /* DSB (Data Synchronization Barrier) operation will complete when all \n     * explicit memory accesses before this instruction have completed.\n     * No instructions after the DSB will be executed until the DSB\n     * instruction has completed, that is, when all of the pending accesses\n     * have completed. */\n   // __DSB();\n\n    /* ISB (Instruction Synchronization Barrier)flushes the pipeline in\n     * the processor, so that all instructions following the ISB are\n     * fetched from cache or memory, after the instruction has been\n     * completed. It ensures that changes to the system, for example\n     * the MPU, take immediate effect.*/\n   // __ISB();\n        \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      if ((++scheduler_counter) == MW_SCHEDULERCOUNTER) {\n         scheduler_counter = 0;\n    #endif\n    \n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          /* Overrun detected */\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n    \n\trt_OneStep();\n    \n      #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      }\n    #endif\n\n    ENABLE_SCHEDULER_INT();\n} \n\n#ifndef _MW_ARDUINO_LOOP_\n#ifdef _ARDUINO_MKR1000_TIMER_5_\n__attribute__ ((naked)) void TC5_Handler(void)\n#elif defined(_ARDUINO_MKR1000_TIMER_4_)\n__attribute__ ((naked)) void TC4_Handler(void)\n#elif defined(_ARDUINO_MKR1000_TIMER_3_)\n__attribute__ ((naked)) void TC3_Handler(void)\n#elif defined(_ARDUINO_MKR1000_RTC_TIMER_)\n__attribute__ ((naked)) void RTC_Handler(void)\n#endif\n{\n    /* Multi tasking, enable re-entrancy */\n    \n    /* Naked functions need the following prolog */\n    ARM_CORTEX_M_PUSH_THREADS_PSR_AND_RET_ADDR();\n    \n    /* Needs to be called to reenable the Timer interrupt */\n    #if defined(_ARDUINO_MKR1000_TIMER_5_)\n       TC5->COUNT16.INTFLAG.bit.MC0 = 1;\n    #elif defined(_ARDUINO_MKR1000_TIMER_4_) \n       TC4->COUNT16.INTFLAG.bit.MC0 = 1;\n    #elif defined(_ARDUINO_MKR1000_TIMER_3_) \n       TC3->COUNT16.INTFLAG.bit.MC0 = 1;\n    #elif defined(_ARDUINO_MKR1000_RTC_TIMER_)\n       RTC->MODE0.INTFLAG.bit.CMP0 = 1;\n    #endif\n    \n    /* Context switch to rt_OneStep() */\n    arm_cortex_m_call_thread_with_context_switch(Scheduler_Isr);\n}\n\n#endif\n\nextern \"C\" void configureArduinoARM_M0plusTimer(void)\n{\n    #if defined(_ARDUINO_MKR1000_TIMER_5_)\n      Setup_SchedulerTimer(TC_FOR_TIMER5, ID_TC_FOR_TIMER5, IRQn_FOR_TIMER5, MW_CLK_DIV, MW_TIMERCOUNT);\n    #elif defined(_ARDUINO_MKR1000_TIMER_4_) \n      Setup_SchedulerTimer(TC_FOR_TIMER4, ID_TC_FOR_TIMER4, IRQn_FOR_TIMER4, MW_CLK_DIV, MW_TIMERCOUNT);\n    #elif defined(_ARDUINO_MKR1000_TIMER_3_) \n      Setup_SchedulerTimer(TC_FOR_TIMER3, ID_TC_FOR_TIMER3, IRQn_FOR_TIMER3, MW_CLK_DIV, MW_TIMERCOUNT);\n    #elif defined(_ARDUINO_MKR1000_RTC_TIMER_)\n      Setup_SchedulerRTC(MW_CLK_DIV, MW_TIMERCOUNT);\n      \n      //TESTT\n      //Setup_SchedulerRTC(RTC_MODE0_CTRL_PRESCALER_DIV2, 10);\n    #endif\n}\n\n#ifdef _ARDUINO_MKR1000_RTC_TIMER_\n//Disable RTC\nvoid rtcDisable()\n{\n  RTC->MODE0.CTRL.reg &= ~RTC_MODE0_CTRL_ENABLE;\n  while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY);\n}\n#endif\n \nvoid Setup_SchedulerRTC(uint16_t prescaler, uint32_t tickCounter)\n{\n#ifndef _MW_ARDUINO_LOOP_ \n\n    NVIC_DisableIRQ(RTC_IRQn);                                                                        /* Configure interrupt request */\n    NVIC_ClearPendingIRQ(RTC_IRQn);\n    NVIC_SetPriority(RTC_IRQn, (1<<__NVIC_PRIO_BITS) - 1);\n    GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK3 | GCLK_CLKCTRL_ID(GCM_RTC));\n    while (GCLK->STATUS.bit.SYNCBUSY);\n\n\n    RTC->MODE0.CTRL.reg &= ~RTC_MODE0_CTRL_ENABLE;\n    while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY);\n\n    /* Reset RTC */\n    RTC->MODE0.CTRL.reg = RTC_MODE0_CTRL_SWRST;\n    while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY);\n    while (RTC->MODE0.CTRL.bit.SWRST);\n\n    RTC->MODE0.CTRL.reg |= RTC_MODE0_CTRL_MODE_COUNT32 | prescaler | RTC_MODE0_CTRL_MATCHCLR;        /* Set mode to count 32bit, Prescalar 1, Clear on match(No need to reset counter)*/\n    while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY);\n\n    RTC->MODE0.COMP[0].reg=tickCounter;                                                              /* Compare value */\n    while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY);\n\n    RTC->MODE0.INTENSET.bit.CMP0 = 1;                                                                /* Enable the RTC interrupt request */\n\n    NVIC_EnableIRQ(RTC_IRQn);\n    \n    RTC->MODE0.CTRL.reg |= RTC_MODE0_CTRL_ENABLE; //set the CTRLA register\n    while (RTC->MODE0.STATUS.reg & RTC_STATUS_SYNCBUSY); //wait until snyc'd\n#endif\n}\n\nvoid Setup_SchedulerTimer(Tc *tc, uint8_t timerId, IRQn_Type irqn, uint16_t prescaler, uint16_t tickCounter)\n{\n#ifndef _MW_ARDUINO_LOOP_    \n    /* Configure interrupt request*/\n    NVIC_DisableIRQ(irqn);\n    NVIC_ClearPendingIRQ(irqn);\n    NVIC_SetPriority(irqn,(1<<__NVIC_PRIO_BITS) - 1);\n    \n    /*Enable GCLK for Timer TCx with source GCLK0 48MHz */ \n    GCLK->CLKCTRL.reg = (uint16_t) (GCLK_CLKCTRL_CLKEN | GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_ID(timerId)) ;\n\n  /* Wait for sync */\n  while (GCLK->STATUS.bit.SYNCBUSY);\n\n  /* TCx reset */\n    tc->COUNT16.CTRLA.reg = TC_CTRLA_SWRST;\n    while (tc->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY);\n    while (tc->COUNT16.CTRLA.bit.SWRST);\n    \n  /* Set TCx Mode to 16 bits, match frequency, prescaler */\n   tc->COUNT16.CTRLA.reg |= TC_CTRLA_MODE_COUNT16 | TC_CTRLA_WAVEGEN_MFRQ | prescaler ;\n   /* Wait for sync */\n    tc->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;\n     \n    /* Load count */\n    tc->COUNT16.CC[0].reg = (uint16_t)tickCounter;\n\n    /* Wait for sync */\n    tc->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;\n\n    /* Set TCx interrupt request high */\n    tc->COUNT16.INTENSET.bit.MC0 = 1;\n\n    /* Wait for sync */\n    tc->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;\n\n   /*TC start counter: Enable TC*/\n    tc->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;\n    \n    /* Wait for sync */\n    tc->COUNT16.STATUS.reg & TC_STATUS_SYNCBUSY;\n    \n    /*Enable interrupt request */\n    NVIC_EnableIRQ(irqn);\n#endif    \n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n    // Disable the overflow interrupt for XCP External Mode\n        #if defined(_ARDUINO_MKR1000_TIMER_5_)\n        if (NVIC->ISER[0U] & (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn_FOR_TIMER5) & 0x1FUL)))\n        {\n            t_return = 1U; \n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER5);\n        #elif defined(_ARDUINO_MKR1000_TIMER_4_)\n        if (NVIC->ISER[0U] & (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn_FOR_TIMER4) & 0x1FUL)))\n        {\n            t_return = 1U; \n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER4);\n        #elif defined(_ARDUINO_MKR1000_TIMER_3_)\n        if (NVIC->ISER[0U] & (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn_FOR_TIMER3) & 0x1FUL)))\n        {\n            t_return = 1U; \n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER3);\n        #elif defined(_ARDUINO_MKR1000_RTC_TIMER_)\n        if (NVIC->ISER[0U] & (uint32_t)(1UL << (((uint32_t)(int32_t)RTC_IRQn) & 0x1FUL)))\n        {\n            t_return = 1U; \n        }\n        NVIC_DisableIRQ(RTC_IRQn);\n    #endif\n#endif\n    return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n    // Enable the overflow interrupt\n    #if defined(_ARDUINO_MKR1000_TIMER_5_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER5);\n    #elif defined(_ARDUINO_MKR1000_TIMER_4_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER4);\n    #elif defined(_ARDUINO_MKR1000_TIMER_3_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER3);\n    #elif defined(_ARDUINO_MKR1000_RTC_TIMER_)\n        NVIC_EnableIRQ(RTC_IRQn);\n    #endif\n#endif\n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n\n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n    }\n#endif\n        \n    ret = 1;\n    return ret;\n}\n\n// LocalWords:  Bareboard Onestep DSB ISB MPU RTC PRESCALER SVC Prescalar CTRLA snyc'd GCLK TCx\n// LocalWords:  prescaler XCP\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"C:\\Milestone 3\\LineFollowing3_ert_rtw\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2023a\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2022 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(ESP_PLATFORM)\n            Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n            #else\n            Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(ESP_PLATFORM)\n            Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(ESP_PLATFORM)\n            Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.begin(r,config);\n            #endif\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeAnalogInput(uint32_t pinNumber)\n{\n    if (pinNumber < A0)\n        pinNumber += A0;\n    pinMode(pinNumber, INPUT);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif"},{"name":"m0m1m0plus_multitasking.c","type":"source","group":"legacy","path":"C:\\Program Files\\MATLAB\\R2023a\\toolbox\\target\\shared\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2020 The MathWorks, Inc. */\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n/* Re-entrant function for multi-tasking: arm_cortex_m_call_thread_with_context_switch*/\n\n__attribute__ ((naked,aligned(4))) void arm_cortex_m_call_thread_with_context_switch(void (* isr_routine_ptr)(void)) {\n     __asm volatile (\"     push {r0, r1}\");\n     __asm volatile (\"     SUB SP, SP, #0x20\");\n     __asm volatile (\"     ADR R0,Call_isr_routine_in_thread_mode\");\n     __asm volatile (\"     NOP\");\n     __asm volatile (\"     STR R0,[SP, #24]\");\n     __asm volatile (\"     MOV R0,#0x01\");\n     __asm volatile (\"     LSL R0,#24\");\n     __asm volatile (\"     STR R0,[SP, #28]\");\n     __asm volatile (\"     MOV R0,#0x6\");\n     __asm volatile (\"     mvn r0, r0\");\n     __asm volatile (\"     MOV LR, R0\");\n     __asm volatile (\"     BX LR\");\n     __asm volatile (\"Call_isr_routine_in_thread_mode:\");\n     __asm volatile (\"     pop {r0, r1}\");\n     __asm volatile (\"     BLX R0\");\n     __asm volatile (\"     ISB\");\n     __asm volatile (\"     SVC #0\");\n     __asm volatile (\"Unknown_Execution:\");\n     __asm volatile (\"     B Unknown_Execution\");\n}\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n     __asm volatile (\"     MOVS r0, #0x4\");\n     __asm volatile (\"     MOV r1, LR\");\n     __asm volatile (\"     TST r0, r1\");\n     __asm volatile (\"     BEQ stack_used_msp\");\n     __asm volatile (\"     MRS R0, PSP\");\n     __asm volatile (\"     B get_service_request\");\n     __asm volatile (\"stack_used_msp:\");\n     __asm volatile (\"     MRS R0, MSP\");\n     __asm volatile (\"get_service_request:\");\n     __asm volatile (\"     LDR R1, [R0, #24]\");\n     __asm volatile (\"     SUB R1, R1, #0x2\");\n     __asm volatile (\"     LDRB R0, [R1]\");\n     __asm volatile (\"     CMP R0, #0\");\n     __asm volatile (\"     BEQ svc_service_0\");\n     __asm volatile (\"     B Unknown_SVC_Request\");\n     __asm volatile (\"svc_service_0:\");\n     __asm volatile (\"     ADD SP, SP, #32\");\n     __asm volatile (\"     POP {R0, R1}\");\n     __asm volatile (\"     MSR APSR_nzcvq, R0\");\n     __asm volatile (\"     BX R1\");\n     __asm volatile (\"Unknown_SVC_Request:\");\n     __asm volatile (\"     B Unknown_SVC_Request\");\n}\n\n/* LocalWords:  ADR isr MOV mvn BLX ISB SVC MOVS TST BEQ msp PSP LDR LDRB CMP LSRS MVNS\n * LocalWords:  svc MSR APSR nzcvq\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};